[
    {
        "properties_json_str": "{\n  \"JSON_File_Name\": \"test_vacancy\",\n  \"properties\": {\n    \"symmetry_equivalence\": {\n      \"description\": \"Checks if two vacancy defects are symmetry equivalent.\",\n      \"format\": \"bool\",\n      \"value\": \"True\"\n    },\n    \"vacancy_string_representation\": {\n      \"description\": \"String representation of the vacancy defect, indicating the element and site index.\",\n      \"format\": \"str\",\n      \"value\": \"Ga Vacancy defect at site #0\"\n    },\n    \"vacancy_oxidation_state\": {\n      \"description\": \"Oxidation state of the vacancy defect.\",\n      \"format\": \"int\",\n      \"value\": \"-3\"\n    },\n    \"vacancy_charge_states\": {\n      \"description\": \"Possible charge states for the vacancy defect.\",\n      \"format\": \"list\",\n      \"value\": \"[-4, -3, -2, -1, 0, 1]\"\n    },\n    \"vacancy_multiplicity\": {\n      \"description\": \"Multiplicity of the vacancy defect, indicating the number of symmetry-equivalent sites.\",\n      \"format\": \"int\",\n      \"value\": \"2\"\n    },\n    \"vacancy_supercell_formula\": {\n      \"description\": \"Chemical formula of the supercell structure containing the vacancy defect.\",\n      \"format\": \"str\",\n      \"value\": \"Ga63 N64\"\n    },\n    \"vacancy_name\": {\n      \"description\": \"Name of the vacancy defect, typically indicating the element involved.\",\n      \"format\": \"str\",\n      \"value\": \"v_Ga\"\n    },\n    \"vacancy_self_equivalence\": {\n      \"description\": \"Checks if the vacancy defect is equivalent to itself.\",\n      \"format\": \"bool\",\n      \"value\": \"True\"\n    },\n    \"vacancy_element_changes\": {\n      \"description\": \"Changes in the number of elements due to the vacancy defect.\",\n      \"format\": \"dict\",\n      \"value\": \"{Element('Ga'): -1}\"\n    },\n    \"vacancy_latex_name\": {\n      \"description\": \"LaTeX formatted name of the vacancy defect for scientific documentation.\",\n      \"format\": \"str\",\n      \"value\": \"v$_{\\\\rm Ga}$\"\n    }\n  }\n}",
        "question": "As a materials scientist, you are utilizing Pymatgen to write functions to calculate material properties. Here is what you need to do:\n- Calculate the following properties:\n    - `symmetry_equivalence`: Checks if two vacancy defects are symmetry equivalent. Format: bool.\n    - `vacancy_string_representation`: String representation of the vacancy defect, indicating the element and site index. Format: str.\n    - `vacancy_oxidation_state`: Oxidation state of the vacancy defect. Format: int.\n    - `vacancy_charge_states`: Possible charge states for the vacancy defect. Format: list.\n    - `vacancy_multiplicity`: Multiplicity of the vacancy defect, indicating the number of symmetry-equivalent sites. Format: int.\n    - `vacancy_supercell_formula`: Chemical formula of the supercell structure containing the vacancy defect. Format: str.\n    - `vacancy_name`: Name of the vacancy defect, typically indicating the element involved. Format: str.\n    - `vacancy_self_equivalence`: Checks if the vacancy defect is equivalent to itself. Format: bool.\n    - `vacancy_element_changes`: Changes in the number of elements due to the vacancy defect. Format: dict.\n    - `vacancy_latex_name`: LaTeX formatted name of the vacancy defect for scientific documentation. Format: str.\n\nIf you need to read files or generate data, please refer to the following instructions:\n- Read or Generate Data:\n    - Access the structure file at: `<path>tool_source_code/pymatgen-analysis-defects/tests/test_files/GaN.vasp</path>`.\n    - Use the Pymatgen function:\n    ```python\n    from pymatgen.core import Structure\n    gan_struct = Structure.from_file(file_path / \"GaN.vasp\")\n    ```\n    - Generate vacancy defects using Pymatgen:\n    ```python\n    from pymatgen.analysis.defects.core import Vacancy\n    s = gan_struct.copy()\n    vac = Vacancy(s, s.sites[0])\n    vac2 = Vacancy(s, s.sites[1])\n    ```\n\nAll content is executed within the function, and the function does not require any input to output the result. The format of the function should follow these guidelines:\n- Write a Python function that:\n    - Reads the data from the provided file paths or generate data based on the description in the first section.\n    - Calculates all the properties mentioned above using Pymatgen.\n    - Returns a dictionary where the property names are keys, and the calculated results are the values.\n\n- Ensure your function includes:\n    - Necessary imports (e.g., `from pymatgen.core import Structure`).\n    - Proper file handling or data generation code.\n    - Output in the form of a dictionary as specified above.\n    - A complete docstring with clear input parameters, data types, and a description of the output.\n\n**Write the required Python function for this task**.",
        "new_unit_test": "def test_test_vacancy(properties):\n    import numpy as np\n    from pymatgen.core.periodic_table import Element\n    \n    expected_properties = {\n        \"symmetry_equivalence\": {\n            \"format\": \"bool\",\n            \"value\": True\n        },\n        \"vacancy_string_representation\": {\n            \"format\": \"str\",\n            \"value\": \"Ga Vacancy defect at site #0\"\n        },\n        \"vacancy_oxidation_state\": {\n            \"format\": \"int\",\n            \"value\": -3\n        },\n        \"vacancy_charge_states\": {\n            \"format\": \"list\",\n            \"value\": [-4, -3, -2, -1, 0, 1]\n        },\n        \"vacancy_multiplicity\": {\n            \"format\": \"int\",\n            \"value\": 2\n        },\n        \"vacancy_supercell_formula\": {\n            \"format\": \"str\",\n            \"value\": \"Ga63 N64\"\n        },\n        \"vacancy_name\": {\n            \"format\": \"str\",\n            \"value\": \"v_Ga\"\n        },\n        \"vacancy_self_equivalence\": {\n            \"format\": \"bool\",\n            \"value\": True\n        },\n        \"vacancy_element_changes\": {\n            \"format\": \"dict\",\n            \"value\": {Element('Ga'): -1}\n        },\n        \"vacancy_latex_name\": {\n            \"format\": \"str\",\n            \"value\": \"v$_{\\\\rm Ga}$\"\n        }\n    }\n    \n    errors = []\n    \n    for property_name, expected_info in expected_properties.items():\n        expected_value = expected_info['value']\n        expected_format = expected_info['format']\n        \n        if property_name not in properties:\n            errors.append(f\"{property_name} not found in input properties\")\n            continue\n        \n        actual_value = properties[property_name]\n        \n        # Check type (skip type check for np.allclose cases as it's handled separately)\n        if expected_format != \"np.allclose\" and not isinstance(actual_value, eval(expected_format)):\n            errors.append(f\"{property_name} is not of type {expected_format}\")\n            continue\n        \n        # Check value or use np.allclose for approximate comparisons\n        if expected_format == \"np.allclose\":\n            if not np.allclose(actual_value, expected_value):\n                errors.append(f\"{property_name}: Expected value close to {expected_value} but got {actual_value}\")\n        else:\n            if actual_value != expected_value:\n                errors.append(f\"{property_name}: Expected {expected_value} but got {actual_value}\")\n    \n    if errors:\n        print(\"failed:\", \"; \".join(errors))\n    else:\n        print(\"ok\")"
    },
    {
        "properties_json_str": "{\n  \"JSON_File_Name\": \"test_substitution\",\n  \"properties\": {\n    \"site_specie_symbol\": {\n      \"description\": \"The chemical symbol of the species at a specific site in the structure.\",\n      \"format\": \"str\",\n      \"value\": \"N\"\n    },\n    \"substitution_symmetry_equivalence\": {\n      \"description\": \"Checks if two substitution sites are symmetry equivalent.\",\n      \"format\": \"bool\",\n      \"value\": \"True\"\n    },\n    \"substitution_string_representation\": {\n      \"description\": \"String representation of the substitution defect.\",\n      \"format\": \"str\",\n      \"value\": \"O subsitituted on the N site at at site #3\"\n    },\n    \"substitution_oxidation_state\": {\n      \"description\": \"Oxidation state of the substitution defect.\",\n      \"format\": \"int\",\n      \"value\": \"1\"\n    },\n    \"substitution_charge_states\": {\n      \"description\": \"Possible charge states for the substitution defect.\",\n      \"format\": \"list\",\n      \"value\": \"[-1, 0, 1, 2]\"\n    },\n    \"substitution_multiplicity\": {\n      \"description\": \"Multiplicity of the substitution defect in the structure.\",\n      \"format\": \"int\",\n      \"value\": \"2\"\n    },\n    \"supercell_site_specie_symbol\": {\n      \"description\": \"The chemical symbol of the species at the defect site in the supercell structure.\",\n      \"format\": \"str\",\n      \"value\": \"O\"\n    },\n    \"supercell_formula\": {\n      \"description\": \"Chemical formula of the supercell structure containing the defect.\",\n      \"format\": \"str\",\n      \"value\": \"Ga64 N63 O1\"\n    },\n    \"substitution_name\": {\n      \"description\": \"Name of the substitution defect.\",\n      \"format\": \"str\",\n      \"value\": \"O_N\"\n    },\n    \"substitution_latex_name\": {\n      \"description\": \"LaTeX formatted name of the substitution defect.\",\n      \"format\": \"str\",\n      \"value\": \"O$_{\\\\rm N}$\"\n    },\n    \"substitution_element_changes\": {\n      \"description\": \"Elemental changes due to the substitution defect.\",\n      \"format\": \"dict\",\n      \"value\": \"{Element('N'): -1, Element('O'): 1}\"\n    },\n    \"free_sites_intersection_ratio\": {\n      \"description\": \"Ratio of the intersection to the union of free sites in the supercell with locking.\",\n      \"format\": \"float\",\n      \"value\": \"1.0\"\n    },\n    \"perturbation_free_sites\": {\n      \"description\": \"Set of free site indices after perturbation in the supercell structure.\",\n      \"format\": \"set\",\n      \"value\": \"set(free_sites_ref2)\"\n    },\n    \"user_defined_charge_states\": {\n      \"description\": \"User-defined charge states for the substitution defect.\",\n      \"format\": \"list\",\n      \"value\": \"[-100, 102]\"\n    },\n    \"default_charge_states\": {\n      \"description\": \"Default charge states for the substitution defect when no user charges are defined.\",\n      \"format\": \"list\",\n      \"value\": \"[-1, 0, 1, 2]\"\n    },\n    \"target_fractional_coordinates\": {\n      \"description\": \"Fractional coordinates of the defect site in the supercell structure.\",\n      \"format\": \"np.allclose\",\n      \"value\": \"[0.1250, 0.0833335, 0.18794]\"\n    },\n    \"closest_equivalent_site_coordinates\": {\n      \"description\": \"Fractional coordinates of the closest equivalent site after changing target coordinates.\",\n      \"format\": \"np.allclose\",\n      \"value\": \"[0.375, 0.5833335, 0.68794]\"\n    },\n    \"antisite_charge_states\": {\n      \"description\": \"Charge states for an antisite substitution defect.\",\n      \"format\": \"list\",\n      \"value\": \"[-7, -6, -5, -4, -3, -2, -1, 0, 1]\"\n    }\n  }\n}",
        "question": "As a materials scientist, you are utilizing Pymatgen to write functions to calculate material properties. Here is what you need to do:\n- Calculate the following properties:\n    - `site_specie_symbol`: The chemical symbol of the species at a specific site in the structure. Format: str.\n    - `substitution_symmetry_equivalence`: Checks if two substitution sites are symmetry equivalent. Format: bool.\n    - `substitution_string_representation`: String representation of the substitution defect. Format: str.\n    - `substitution_oxidation_state`: Oxidation state of the substitution defect. Format: int.\n    - `substitution_charge_states`: Possible charge states for the substitution defect. Format: list.\n    - `substitution_multiplicity`: Multiplicity of the substitution defect in the structure. Format: int.\n    - `supercell_site_specie_symbol`: The chemical symbol of the species at the defect site in the supercell structure. Format: str.\n    - `supercell_formula`: Chemical formula of the supercell structure containing the defect. Format: str.\n    - `substitution_name`: Name of the substitution defect. Format: str.\n    - `substitution_latex_name`: LaTeX formatted name of the substitution defect. Format: str.\n    - `substitution_element_changes`: Elemental changes due to the substitution defect. Format: dict.\n    - `free_sites_intersection_ratio`: Ratio of the intersection to the union of free sites in the supercell with locking. Format: float.\n    - `perturbation_free_sites`: Set of free site indices after perturbation in the supercell structure. Format: set.\n    - `user_defined_charge_states`: User-defined charge states for the substitution defect. Format: list.\n    - `default_charge_states`: Default charge states for the substitution defect when no user charges are defined. Format: list.\n    - `target_fractional_coordinates`: Fractional coordinates of the defect site in the supercell structure. Format: np.allclose.\n    - `closest_equivalent_site_coordinates`: Fractional coordinates of the closest equivalent site after changing target coordinates. Format: np.allclose.\n    - `antisite_charge_states`: Charge states for an antisite substitution defect. Format: list.\n\nIf you need to read files or generate data, please refer to the following instructions:\n- Read or Generate Data:\n    - Access the structure file at: `<path>tool_source_code/pymatgen-analysis-defects/tests/test_files/GaN.vasp</path>`.\n    - Use the Pymatgen function:\n    ```python\n    from pymatgen.core import Structure\n    gan_struct = Structure.from_file(file_path / \"GaN.vasp\")\n    ```\n    - Generate substitution defects and supercell structures using Pymatgen:\n    ```python\n    from pymatgen.analysis.defects.core import PeriodicSite, Substitution\n    from pymatgen.core.periodic_table import Specie\n    s = gan_struct.copy()\n    n_site = s.sites[3]\n    o_site = PeriodicSite(Specie(\"O\"), n_site.frac_coords, s.lattice)\n    o_site2 = PeriodicSite(Specie(\"O\"), s.sites[2].frac_coords, s.lattice)\n    sub = Substitution(s, o_site)\n    sub2 = Substitution(s, o_site2)\n    sc, site_ = sub.get_supercell_structure(return_site=True)\n    sc_locked = sub.get_supercell_structure(relax_radius=5.0)\n    free_sites = [\n        i\n        for i, site in enumerate(sc_locked)\n        if site.properties[\"selective_dynamics\"][0]\n    ]\n    finder = DefectSiteFinder()\n    fpos = finder.get_defect_fpos(sc_locked, sub.structure)\n    cpos = sc_locked.lattice.get_cartesian_coords(fpos)\n    free_sites_ref = sc_locked.get_sites_in_sphere(cpos, 5.0, include_index=True)\n    free_sites_ref = [site.index for site in free_sites_ref]\n    sc_locked = sub.get_supercell_structure(relax_radius=5.0, perturb=0.0)\n    free_sites_ref2 = sc_locked.get_sites_in_sphere(cpos, 5.0, include_index=True)\n    free_sites_ref2 = [site.index for site in free_sites_ref2]\n    dd = sub.as_dict()\n    dd[\"user_charges\"] = [-100, 102]\n    sub_ = Substitution.from_dict(dd)\n    sub_sc_struct = sub.get_supercell_structure()\n    fpos = finder.get_defect_fpos(sub_sc_struct, sub.structure)\n    sub_sc_struct = sub.get_supercell_structure(target_frac_coords=[0.3, 0.5, 0.9])\n    fpos = finder.get_defect_fpos(sub_sc_struct, sub.structure)\n    ga_site = s.sites[0]\n    n_site = PeriodicSite(Specie(\"N\"), ga_site.frac_coords, s.lattice)\n    n_ga = Substitution(s, n_site)\n    s.remove_oxidation_states()\n    ga_site = s.sites[0]\n    n_site = PeriodicSite(Element(\"N\"), ga_site.frac_coords, s.lattice)\n    n_ga = Substitution(s, n_site)\n    ```\n\nAll content is executed within the function, and the function does not require any input to output the result. The format of the function should follow these guidelines:\n- Write a Python function that:\n    - Reads the data from the provided file paths or generate data based on the description in the first section.\n    - Calculates all the properties mentioned above using Pymatgen.\n    - Returns a dictionary where the property names are keys, and the calculated results are the values.\n\n- Ensure your function includes:\n    - Necessary imports (e.g., `from pymatgen.core import Structure`).\n    - Proper file handling or data generation code.\n    - Output in the form of a dictionary as specified above.\n    - A complete docstring with clear input parameters, data types, and a description of the output.\n\n**Write the required Python function for this task**.",
        "new_unit_test": "def test_test_substitution(properties):\n    import numpy as np\n    from pymatgen.core.periodic_table import Element\n    \n    expected_properties = {\n        \"site_specie_symbol\": {\n            \"format\": \"str\",\n            \"value\": \"N\"\n        },\n        \"substitution_symmetry_equivalence\": {\n            \"format\": \"bool\",\n            \"value\": True\n        },\n        \"substitution_string_representation\": {\n            \"format\": \"str\",\n            \"value\": \"O subsitituted on the N site at at site #3\"\n        },\n        \"substitution_oxidation_state\": {\n            \"format\": \"int\",\n            \"value\": 1\n        },\n        \"substitution_charge_states\": {\n            \"format\": \"list\",\n            \"value\": [-1, 0, 1, 2]\n        },\n        \"substitution_multiplicity\": {\n            \"format\": \"int\",\n            \"value\": 2\n        },\n        \"supercell_site_specie_symbol\": {\n            \"format\": \"str\",\n            \"value\": \"O\"\n        },\n        \"supercell_formula\": {\n            \"format\": \"str\",\n            \"value\": \"Ga64 N63 O1\"\n        },\n        \"substitution_name\": {\n            \"format\": \"str\",\n            \"value\": \"O_N\"\n        },\n        \"substitution_latex_name\": {\n            \"format\": \"str\",\n            \"value\": \"O$_{\\\\rm N}$\"\n        },\n        \"substitution_element_changes\": {\n            \"format\": \"dict\",\n            \"value\": {Element('N'): -1, Element('O'): 1}\n        },\n        \"free_sites_intersection_ratio\": {\n            \"format\": \"float\",\n            \"value\": 1.0\n        },\n        \"perturbation_free_sites\": {\n            \"format\": \"set\",\n            \"value\": set(free_sites_ref2)\n        },\n        \"user_defined_charge_states\": {\n            \"format\": \"list\",\n            \"value\": [-100, 102]\n        },\n        \"default_charge_states\": {\n            \"format\": \"list\",\n            \"value\": [-1, 0, 1, 2]\n        },\n        \"target_fractional_coordinates\": {\n            \"format\": \"np.allclose\",\n            \"value\": [0.1250, 0.0833335, 0.18794]\n        },\n        \"closest_equivalent_site_coordinates\": {\n            \"format\": \"np.allclose\",\n            \"value\": [0.375, 0.5833335, 0.68794]\n        },\n        \"antisite_charge_states\": {\n            \"format\": \"list\",\n            \"value\": [-7, -6, -5, -4, -3, -2, -1, 0, 1]\n        }\n    }\n    \n    errors = []\n    \n    for property_name, expected_info in expected_properties.items():\n        expected_value = expected_info['value']\n        expected_format = expected_info['format']\n        \n        if property_name not in properties:\n            errors.append(f\"{property_name} not found in input properties\")\n            continue\n        \n        actual_value = properties[property_name]\n        \n        # Check type (skip type check for np.allclose cases as it's handled separately)\n        if expected_format != \"np.allclose\" and not isinstance(actual_value, eval(expected_format)):\n            errors.append(f\"{property_name} is not of type {expected_format}\")\n            continue\n        \n        # Check value or use np.allclose for approximate comparisons\n        if expected_format == \"np.allclose\":\n            if not np.allclose(actual_value, expected_value):\n                errors.append(f\"{property_name}: Expected value close to {expected_value} but got {actual_value}\")\n        else:\n            if actual_value != expected_value:\n                errors.append(f\"{property_name}: Expected {expected_value} but got {actual_value}\")\n    \n    if errors:\n        print(\"failed:\", \"; \".join(errors))\n    else:\n        print(\"ok\")"
    },
    {
        "properties_json_str": "{\n  \"JSON_File_Name\": \"test_interstitial\",\n  \"properties\": {\n    \"oxidation_state\": {\n      \"description\": \"The oxidation state of the interstitial defect site.\",\n      \"format\": \"int\",\n      \"value\": 3\n    },\n    \"charge_states\": {\n      \"description\": \"Possible charge states for the interstitial defect.\",\n      \"format\": \"list\",\n      \"value\": [-1, 0, 1, 2, 3, 4]\n    },\n    \"fractional_coordinates\": {\n      \"description\": \"Fractional coordinates of the interstitial defect site within the lattice.\",\n      \"format\": \"np.allclose\",\n      \"value\": [0, 0, 0.75]\n    },\n    \"supercell_formula\": {\n      \"description\": \"Chemical formula of the supercell containing the interstitial defect.\",\n      \"format\": \"str\",\n      \"value\": \"Ga64 N65\"\n    },\n    \"defect_name\": {\n      \"description\": \"Name of the interstitial defect, indicating the element and type of defect.\",\n      \"format\": \"str\",\n      \"value\": \"N_i\"\n    },\n    \"defect_string_representation\": {\n      \"description\": \"String representation of the interstitial defect, including its position.\",\n      \"format\": \"str\",\n      \"value\": \"N intersitial site at [0.00,0.00,0.75]\"\n    },\n    \"element_changes\": {\n      \"description\": \"Changes in the number of elements due to the interstitial defect.\",\n      \"format\": \"dict\",\n      \"value\": {\"N\": 1}\n    },\n    \"latex_name\": {\n      \"description\": \"LaTeX formatted name of the interstitial defect.\",\n      \"format\": \"str\",\n      \"value\": \"N$_{\\\\rm i}$\"\n    },\n    \"defect_fpos_initial\": {\n      \"description\": \"Fractional coordinates of the defect site in the supercell structure.\",\n      \"format\": \"np.allclose\",\n      \"value\": [0, 0, 0.398096581]\n    },\n    \"defect_fpos_modified\": {\n      \"description\": \"Fractional coordinates of the defect site in the modified supercell structure.\",\n      \"format\": \"np.allclose\",\n      \"value\": [0.25, 0.5, 0.89809658]\n    },\n    \"user_defined_charge_states\": {\n      \"description\": \"User-defined charge states for the interstitial defect.\",\n      \"format\": \"list\",\n      \"value\": [-100, 102]\n    }\n  }\n}",
        "question": "As a materials scientist, you are utilizing Pymatgen to write functions to calculate material properties. Here is what you need to do:\n- Calculate the following properties for an interstitial defect in a GaN structure:\n    - `oxidation_state`: The oxidation state of the interstitial defect site. (int)\n    - `charge_states`: Possible charge states for the interstitial defect. (list)\n    - `fractional_coordinates`: Fractional coordinates of the interstitial defect site within the lattice. (np.allclose)\n    - `supercell_formula`: Chemical formula of the supercell containing the interstitial defect. (str)\n    - `defect_name`: Name of the interstitial defect, indicating the element and type of defect. (str)\n    - `defect_string_representation`: String representation of the interstitial defect, including its position. (str)\n    - `element_changes`: Changes in the number of elements due to the interstitial defect. (dict)\n    - `latex_name`: LaTeX formatted name of the interstitial defect. (str)\n    - `defect_fpos_initial`: Fractional coordinates of the defect site in the supercell structure. (np.allclose)\n    - `defect_fpos_modified`: Fractional coordinates of the defect site in the modified supercell structure. (np.allclose)\n    - `user_defined_charge_states`: User-defined charge states for the interstitial defect. (list)\n\nIf you need to read files or generate data, please refer to the following instructions:\n- Read or Generate Data:\n    - Access the structure file at: `<path>tool_source_code/pymatgen-analysis-defects/tests/test_files/GaN.vasp</path>`.\n    - Use the Pymatgen function:\n    ```python\n    from pymatgen.core import Structure\n    gan_struct = Structure.from_file(file_path / \"GaN.vasp\")\n    ```\n    - Generate an interstitial defect using Pymatgen:\n    ```python\n    from pymatgen.analysis.defects.core import Interstitial, PeriodicSite\n    from pymatgen.core.periodic_table import Specie\n    s = gan_struct.copy()\n    inter_fpos = [0, 0, 0.75]\n    n_site = PeriodicSite(Specie(\"N\"), inter_fpos, s.lattice)\n    inter = Interstitial(s, n_site)\n    ```\n\nAll content is executed within the function, and the function does not require any input to output the result. The format of the function should follow these guidelines:\n- Write a Python function that:\n    - Reads the data from the provided file paths or generate data based on the description in the first section.\n    - Calculates all the properties mentioned above using Pymatgen.\n    - Returns a dictionary where the property names are keys, and the calculated results are the values.\n\n- Ensure your function includes:\n    - Necessary imports (e.g., `from pymatgen.core import Structure`).\n    - Proper file handling or data generation code.\n    - Output in the form of a dictionary as specified above.\n    - A complete docstring with clear input parameters, data types, and a description of the output.\n\n**Write the required Python function for this task**.",
        "new_unit_test": "def test_test_interstitial(properties):\n    import numpy as np\n    expected_properties = {\n        \"oxidation_state\": {\n            \"format\": \"int\",\n            \"value\": 3\n        },\n        \"charge_states\": {\n            \"format\": \"list\",\n            \"value\": [-1, 0, 1, 2, 3, 4]\n        },\n        \"fractional_coordinates\": {\n            \"format\": \"np.allclose\",\n            \"value\": [0, 0, 0.75]\n        },\n        \"supercell_formula\": {\n            \"format\": \"str\",\n            \"value\": \"Ga64 N65\"\n        },\n        \"defect_name\": {\n            \"format\": \"str\",\n            \"value\": \"N_i\"\n        },\n        \"defect_string_representation\": {\n            \"format\": \"str\",\n            \"value\": \"N intersitial site at [0.00,0.00,0.75]\"\n        },\n        \"element_changes\": {\n            \"format\": \"dict\",\n            \"value\": {\"N\": 1}\n        },\n        \"latex_name\": {\n            \"format\": \"str\",\n            \"value\": \"N$_{\\\\rm i}$\"\n        },\n        \"defect_fpos_initial\": {\n            \"format\": \"np.allclose\",\n            \"value\": [0, 0, 0.398096581]\n        },\n        \"defect_fpos_modified\": {\n            \"format\": \"np.allclose\",\n            \"value\": [0.25, 0.5, 0.89809658]\n        },\n        \"user_defined_charge_states\": {\n            \"format\": \"list\",\n            \"value\": [-100, 102]\n        }\n    }\n    \n    errors = []\n    \n    for property_name, expected_info in expected_properties.items():\n        expected_value = expected_info['value']\n        expected_format = expected_info['format']\n        \n        if property_name not in properties:\n            errors.append(f\"{property_name} not found in input properties\")\n            continue\n        \n        actual_value = properties[property_name]\n        \n        # Check type (skip type check for np.allclose cases as it's handled separately)\n        if expected_format != \"np.allclose\" and not isinstance(actual_value, eval(expected_format)):\n            errors.append(f\"{property_name} is not of type {expected_format}\")\n            continue\n        \n        # Check value or use np.allclose for approximate comparisons\n        if expected_format == \"np.allclose\":\n            if not np.allclose(actual_value, expected_value):\n                errors.append(f\"{property_name}: Expected value close to {expected_value} but got {actual_value}\")\n        else:\n            if actual_value != expected_value:\n                errors.append(f\"{property_name}: Expected {expected_value} but got {actual_value}\")\n    \n    if errors:\n        print(\"failed:\", \"; \".join(errors))\n    else:\n        print(\"ok\")"
    },
    {
        "properties_json_str": "{\n  \"JSON_File_Name\": \"test_adsorbate\",\n  \"properties\": {\n    \"adsorbate_name\": {\n      \"description\": \"The name of the adsorbate, typically indicating the element and its role as an adsorbate.\",\n      \"format\": \"str\",\n      \"value\": \"N_{ads}\"\n    },\n    \"adsorbate_description\": {\n      \"description\": \"A string representation of the adsorbate site, including the element and its fractional coordinates.\",\n      \"format\": \"str\",\n      \"value\": \"N adsorbate site at [0.00,0.00,0.75]\"\n    }\n  }\n}",
        "question": "As a materials scientist, you are utilizing Pymatgen to write functions to calculate material properties. Here is what you need to do:\n- Calculate the following properties:\n    - `adsorbate_name`: The name of the adsorbate, typically indicating the element and its role as an adsorbate. Format: `str`.\n    - `adsorbate_description`: A string representation of the adsorbate site, including the element and its fractional coordinates. Format: `str`.\n\nIf you need to read files or generate data, please refer to the following instructions:\n- Read or Generate Data:\n    - Access the structure file at: `<path>tool_source_code/pymatgen-analysis-defects/tests/test_files/GaN.vasp</path>`.\n    - Use the Pymatgen function:\n    ```python\n    from pymatgen.core import Structure\n    gan_struct = Structure.from_file(file_path / \"GaN.vasp\")\n    ```\n    - Generate the adsorbate site using Pymatgen:\n    ```python\n    from pymatgen.analysis.defects.core import Adsorbate, PeriodicSite\n    from pymatgen.core.periodic_table import Specie\n    s = gan_struct.copy()\n    ads_fpos = [0, 0, 0.75]\n    n_site = PeriodicSite(Specie(\"N\"), ads_fpos, s.lattice)\n    ads = Adsorbate(s, n_site)\n    ```\n\nAll content is executed within the function, and the function does not require any input to output the result. The format of the function should follow these guidelines:\n- Write a Python function that:\n    - Reads the data from the provided file paths or generate data based on the description in the first section.\n    - Calculates all the properties mentioned above using Pymatgen.\n    - Returns a dictionary where the property names are keys, and the calculated results are the values.\n\n- Ensure your function includes:\n    - Necessary imports (e.g., `from pymatgen.core import Structure`).\n    - Proper file handling or data generation code.\n    - Output in the form of a dictionary as specified above.\n    - A complete docstring with clear input parameters, data types, and a description of the output.\n\n**Write the required Python function for this task**.",
        "new_unit_test": "def test_test_adsorbate(properties):\n    import numpy as np\n    expected_properties = {\n        \"adsorbate_name\": {\n            \"format\": \"str\",\n            \"value\": \"N_{ads}\"\n        },\n        \"adsorbate_description\": {\n            \"format\": \"str\",\n            \"value\": \"N adsorbate site at [0.00,0.00,0.75]\"\n        }\n    }\n    \n    errors = []\n    \n    for property_name, expected_info in expected_properties.items():\n        expected_value = expected_info['value']\n        expected_format = expected_info['format']\n        \n        if property_name not in properties:\n            errors.append(f\"{property_name} not found in input properties\")\n            continue\n        \n        actual_value = properties[property_name]\n        \n        # Check type (skip type check for np.allclose cases as it's handled separately)\n        if expected_format != \"np.allclose\" and not isinstance(actual_value, eval(expected_format)):\n            errors.append(f\"{property_name} is not of type {expected_format}\")\n            continue\n        \n        # Check value or use np.allclose for approximate comparisons\n        if expected_format == \"np.allclose\":\n            if not np.allclose(actual_value, expected_value):\n                errors.append(f\"{property_name}: Expected value close to {expected_value} but got {actual_value}\")\n        else:\n            if actual_value != expected_value:\n                errors.append(f\"{property_name}: Expected {expected_value} but got {actual_value}\")\n    \n    if errors:\n        print(\"failed:\", \"; \".join(errors))\n    else:\n        print(\"ok\")"
    },
    {
        "properties_json_str": "{\n  \"JSON_File_Name\": \"test_complex\",\n  \"properties\": {\n    \"defect_complex_name\": {\n      \"description\": \"The name of the defect complex, indicating the types of defects present.\",\n      \"format\": \"str\",\n      \"value\": \"O_N+v_Ga\"\n    },\n    \"supercell_structure_formula\": {\n      \"description\": \"The chemical formula of the supercell structure after introducing the defect complex.\",\n      \"format\": \"str\",\n      \"value\": \"Ga63 N63 O1\"\n    },\n    \"defect_complex_oxidation_state\": {\n      \"description\": \"The total oxidation state of the defect complex, calculated as the sum of the oxidation states of individual defects.\",\n      \"format\": \"int\",\n      \"value\": \"sum of sub.oxi_state and vac.oxi_state\"\n    },\n    \"element_changes\": {\n      \"description\": \"The net change in the number of each element due to the defect complex.\",\n      \"format\": \"dict\",\n      \"value\": \"{Element('Ga'): -1, Element('N'): -1, Element('O'): 1}\"\n    },\n    \"defect_structure_formula\": {\n      \"description\": \"The chemical formula of the defect structure itself, without considering the supercell.\",\n      \"format\": \"str\",\n      \"value\": \"Ga1 N1 O1\"\n    },\n    \"defect_complex_with_interstitial_name\": {\n      \"description\": \"The name of the defect complex including an interstitial defect.\",\n      \"format\": \"str\",\n      \"value\": \"O_N+v_Ga+H_i\"\n    },\n    \"supercell_structure_with_dummy_formula\": {\n      \"description\": \"The chemical formula of the supercell structure with a dummy species added to account for the interstitial defect.\",\n      \"format\": \"str\",\n      \"value\": \"Ga63 H1 Xe1 N63 O1\"\n    },\n    \"defect_complex_equality\": {\n      \"description\": \"Checks if two defect complexes are identical.\",\n      \"format\": \"bool\",\n      \"value\": \"True\"\n    },\n    \"defect_complex_inequality\": {\n      \"description\": \"Checks if two defect complexes are different.\",\n      \"format\": \"bool\",\n      \"value\": \"True\"\n    }\n  }\n}",
        "question": "As a materials scientist, you are utilizing Pymatgen to write functions to calculate material properties. Here is what you need to do:\n- Calculate the following properties:\n    - `defect_complex_name`: The name of the defect complex, indicating the types of defects present. Format: str.\n    - `supercell_structure_formula`: The chemical formula of the supercell structure after introducing the defect complex. Format: str.\n    - `defect_complex_oxidation_state`: The total oxidation state of the defect complex, calculated as the sum of the oxidation states of individual defects. Format: int.\n    - `element_changes`: The net change in the number of each element due to the defect complex. Format: dict.\n    - `defect_structure_formula`: The chemical formula of the defect structure itself, without considering the supercell. Format: str.\n    - `defect_complex_with_interstitial_name`: The name of the defect complex including an interstitial defect. Format: str.\n    - `supercell_structure_with_dummy_formula`: The chemical formula of the supercell structure with a dummy species added to account for the interstitial defect. Format: str.\n    - `defect_complex_equality`: Checks if two defect complexes are identical. Format: bool.\n    - `defect_complex_inequality`: Checks if two defect complexes are different. Format: bool.\n\nIf you need to read files or generate data, please refer to the following instructions:\n- Read or Generate Data:\n    - Access the structure file at: `<path>tool_source_code/pymatgen-analysis-defects/tests/test_files/GaN.vasp</path>`.\n    - Use the Pymatgen function:\n    ```python\n    from pymatgen.core import Structure\n    gan_struct = Structure.from_file(file_path / \"GaN.vasp\")\n    ```\n    - Generate defect complexes using Pymatgen:\n    ```python\n    from pymatgen.analysis.defects.core import PeriodicSite, Substitution, Vacancy, Interstitial, DefectComplex\n    from pymatgen.core.periodic_table import Specie, Element\n\n    s = gan_struct.copy()\n    o_site = PeriodicSite(Specie(\"O\"), s[3].frac_coords, s.lattice)\n    sub = Substitution(s, o_site)  # O substituted on N site\n    vac = Vacancy(s, s.sites[0])  # Ga vacancy\n    inter = Interstitial(s, PeriodicSite(Specie(\"H\"), [0, 0, 0.75], s.lattice))  # H interstitial\n    dc = DefectComplex([sub, vac])\n    dc2 = DefectComplex([sub, vac, inter])\n    ```\n\nAll content is executed within the function, and the function does not require any input to output the result. The format of the function should follow these guidelines:\n- Write a Python function that:\n    - Reads the data from the provided file paths or generate data based on the description in the first section.\n    - Calculates all the properties mentioned above using Pymatgen.\n    - Returns a dictionary where the property names are keys, and the calculated results are the values.\n\n- Ensure your function includes:\n    - Necessary imports (e.g., `from pymatgen.core import Structure`).\n    - Proper file handling or data generation code.\n    - Output in the form of a dictionary as specified above.\n    - A complete docstring with clear input parameters, data types, and a description of the output.\n\n**Write the required Python function for this task**.",
        "new_unit_test": "def test_complex(properties):\n    import numpy as np\n    from pymatgen.core import Element\n    \n    expected_properties = {\n        \"defect_complex_name\": {\n            \"format\": \"str\",\n            \"value\": \"O_N+v_Ga\"\n        },\n        \"supercell_structure_formula\": {\n            \"format\": \"str\",\n            \"value\": \"Ga63 N63 O1\"\n        },\n        \"defect_complex_oxidation_state\": {\n            \"format\": \"int\",\n            \"value\": \"sum of sub.oxi_state and vac.oxi_state\"  # This needs to be calculated based on context\n        },\n        \"element_changes\": {\n            \"format\": \"dict\",\n            \"value\": {Element('Ga'): -1, Element('N'): -1, Element('O'): 1}\n        },\n        \"defect_structure_formula\": {\n            \"format\": \"str\",\n            \"value\": \"Ga1 N1 O1\"\n        },\n        \"defect_complex_with_interstitial_name\": {\n            \"format\": \"str\",\n            \"value\": \"O_N+v_Ga+H_i\"\n        },\n        \"supercell_structure_with_dummy_formula\": {\n            \"format\": \"str\",\n            \"value\": \"Ga63 H1 Xe1 N63 O1\"\n        },\n        \"defect_complex_equality\": {\n            \"format\": \"bool\",\n            \"value\": True\n        },\n        \"defect_complex_inequality\": {\n            \"format\": \"bool\",\n            \"value\": True\n        }\n    }\n    \n    errors = []\n    \n    for property_name, expected_info in expected_properties.items():\n        expected_value = expected_info['value']\n        expected_format = expected_info['format']\n        \n        if property_name not in properties:\n            errors.append(f\"{property_name} not found in input properties\")\n            continue\n        \n        actual_value = properties[property_name]\n        \n        # Check type (skip type check for np.allclose cases as it's handled separately)\n        if expected_format != \"np.allclose\" and not isinstance(actual_value, eval(expected_format)):\n            errors.append(f\"{property_name} is not of type {expected_format}\")\n            continue\n        \n        # Check value or use np.allclose for approximate comparisons\n        if expected_format == \"np.allclose\":\n            if not np.allclose(actual_value, expected_value):\n                errors.append(f\"{property_name}: Expected value close to {expected_value} but got {actual_value}\")\n        else:\n            if actual_value != expected_value:\n                errors.append(f\"{property_name}: Expected {expected_value} but got {actual_value}\")\n    \n    if errors:\n        print(\"failed:\", \"; \".join(errors))\n    else:\n        print(\"ok\")"
    },
    {
        "properties_json_str": "{\n  \"JSON_File_Name\": \"test_parsing_and_grouping_NamedDefects\",\n  \"properties\": {\n    \"element_changes\": {\n      \"description\": \"Represents the change in the number of atoms of each element due to the defect.\",\n      \"format\": \"dict\",\n      \"value\": \"{Element('Mg'): 1, Element('Ga'): -1}\"\n    },\n    \"defect_string_representation\": {\n      \"description\": \"String representation of the NamedDefect, combining the bulk formula and defect name.\",\n      \"format\": \"str\",\n      \"value\": \"GaN:Mg_Ga\"\n    },\n    \"defect_equality\": {\n      \"description\": \"Checks if two NamedDefect objects are equal based on their properties.\",\n      \"format\": \"bool\",\n      \"value\": \"True\"\n    },\n    \"defect_inequality\": {\n      \"description\": \"Checks if two NamedDefect objects are not equal based on their properties.\",\n      \"format\": \"bool\",\n      \"value\": \"True\"\n    }\n  }\n}",
        "question": "As a materials scientist, you are utilizing Pymatgen to write functions to calculate material properties. Here is what you need to do:\n- Calculate the following properties:\n    - `element_changes`: Represents the change in the number of atoms of each element due to the defect. Format: dict.\n    - `defect_string_representation`: String representation of the NamedDefect, combining the bulk formula and defect name. Format: str.\n    - `defect_equality`: Checks if two NamedDefect objects are equal based on their properties. Format: bool.\n    - `defect_inequality`: Checks if two NamedDefect objects are not equal based on their properties. Format: bool.\n\nIf you need to read files or generate data, please refer to the following instructions:\n- Read or Generate Data:\n    - Access the bulk structure file at: `<path>tool_source_code/pymatgen-analysis-defects/tests/test_files/Mg_Ga/bulk_sc/CONTCAR.gz</path>`.\n    - Access the defect structure file at: `<path>tool_source_code/pymatgen-analysis-defects/tests/test_files/Mg_Ga/q=0/CONTCAR.gz</path>`.\n    - Use the Pymatgen function ```python\\nfrom pymatgen.core import Structure\\nbulk_struct = Structure.from_file(bulk_dir / \"CONTCAR.gz\")\\ndefect_struct = Structure.from_file(defect_dir / \"CONTCAR.gz\")\\n``` to read the structure data.\n    - Generate NamedDefect objects using the Pymatgen function: ```python\\nfrom pymatgen.analysis.defects.core import NamedDefect\\nnd0 = NamedDefect.from_structures(defect_structure=defect_struct, bulk_structure=bulk_struct)\\nnd1 = NamedDefect(name=\"v_Ga\", bulk_formula=\"GaN\", element_changes={\"Ga\": -1})\\nnd2 = NamedDefect(name=\"Mg_Ga\", bulk_formula=\"GaN\", element_changes={\"Mg\": 1, \"Ga\": -1})\\n```.\n\nAll content is executed within the function, and the function does not require any input to output the result. The format of the function should follow these guidelines:\n- Write a Python function that:\n    - Reads the data from the provided file paths or generate data based on the description in the first section.\n    - Calculates all the properties mentioned above using Pymatgen.\n    - Returns a dictionary where the property names are keys, and the calculated results are the values.\n\n- Ensure your function includes:\n    - Necessary imports (e.g., `from pymatgen.core import Structure`).\n    - Proper file handling or data generation code.\n    - Output in the form of a dictionary as specified above.\n    - A complete docstring with clear input parameters, data types, and a description of the output.\n\n**Write the required Python function for this task**.",
        "new_unit_test": "def test_parsing_and_grouping_NamedDefects(properties):\n    import numpy as np\n    from pymatgen.core import Element\n    \n    expected_properties = {\n        \"element_changes\": {\n            \"format\": \"dict\",\n            \"value\": {Element('Mg'): 1, Element('Ga'): -1}\n        },\n        \"defect_string_representation\": {\n            \"format\": \"str\",\n            \"value\": \"GaN:Mg_Ga\"\n        },\n        \"defect_equality\": {\n            \"format\": \"bool\",\n            \"value\": True\n        },\n        \"defect_inequality\": {\n            \"format\": \"bool\",\n            \"value\": True\n        }\n    }\n    \n    errors = []\n    \n    for property_name, expected_info in expected_properties.items():\n        expected_value = expected_info['value']\n        expected_format = expected_info['format']\n        \n        if property_name not in properties:\n            errors.append(f\"{property_name} not found in input properties\")\n            continue\n        \n        actual_value = properties[property_name]\n        \n        # Check type (skip type check for np.allclose cases as it's handled separately)\n        if expected_format != \"np.allclose\" and not isinstance(actual_value, eval(expected_format)):\n            errors.append(f\"{property_name} is not of type {expected_format}\")\n            continue\n        \n        # Check value or use np.allclose for approximate comparisons\n        if expected_format == \"np.allclose\":\n            if not np.allclose(actual_value, expected_value):\n                errors.append(f\"{property_name}: Expected value close to {expected_value} but got {actual_value}\")\n        else:\n            if actual_value != expected_value:\n                errors.append(f\"{property_name}: Expected {expected_value} but got {actual_value}\")\n    \n    if errors:\n        print(\"failed:\", \"; \".join(errors))\n    else:\n        print(\"ok\")"
    },
    {
        "properties_json_str": "{\n  \"JSON_File_Name\": \"test_lower_envelope\",\n  \"properties\": {\n    \"lower_envelope\": {\n      \"description\": \"The lower envelope of a set of lines, representing the minimal boundary formed by the lines in a 2D space.\",\n      \"format\": \"list of tuples\",\n      \"value\": \"[(4, 12), (3, 8), (-2, 1), (-5, 4)]\"\n    },\n    \"transitions\": {\n      \"description\": \"The transition points where the lower envelope changes slope, indicating a change in the dominant line segment.\",\n      \"format\": \"list of tuples\",\n      \"value\": \"[(-4, -4), (-1.4, 3.8), (1, -1)]\"\n    }\n  }\n}",
        "question": "As a materials scientist, you are utilizing Pymatgen to write functions to calculate material properties. Here is what you need to do:\n- Calculate the following properties:\n    - `lower_envelope`: The lower envelope of a set of lines, representing the minimal boundary formed by the lines in a 2D space. The format is a list of tuples.\n    - `transitions`: The transition points where the lower envelope changes slope, indicating a change in the dominant line segment. The format is a list of tuples.\n\nIf you need to read files or generate data, please refer to the following instructions:\n- Read or Generate Data:\n    - Generate a set of lines for the lower envelope calculation using the following list: `[[4, 12], [-1, 3], [-5, 4], [-2, 1], [3, 8], [-4, 14], [2, 12], [3, 8]]`.\n    - Use the Pymatgen functions:\n      ```python\n      from pymatgen.analysis.defects.thermo import get_lower_envelope, get_transitions\n      ```\n      to calculate the lower envelope and transitions.\n\nAll content is executed within the function, and the function does not require any input to output the result. The format of the function should follow these guidelines:\n- Write a Python function that:\n    - Generates the data based on the description in the first section.\n    - Calculates all the properties mentioned above using Pymatgen.\n    - Returns a dictionary where the property names are keys, and the calculated results are the values.\n\n- Ensure your function includes:\n    - Necessary imports (e.g., `from pymatgen.analysis.defects.thermo import get_lower_envelope, get_transitions`).\n    - Proper data generation code.\n    - Output in the form of a dictionary as specified above.\n    - A complete docstring with clear input parameters, data types, and a description of the output.\n\n**Write the required Python function for this task**.",
        "new_unit_test": "def test_lower_envelope(properties):\n    import numpy as np\n    expected_properties = {\n        \"lower_envelope\": {\n            \"format\": \"list\",\n            \"value\": [(4, 12), (3, 8), (-2, 1), (-5, 4)]\n        },\n        \"transitions\": {\n            \"format\": \"list\",\n            \"value\": [(-4, -4), (-1.4, 3.8), (1, -1)]\n        }\n    }\n    \n    errors = []\n    \n    for property_name, expected_info in expected_properties.items():\n        expected_value = expected_info['value']\n        expected_format = expected_info['format']\n        \n        if property_name not in properties:\n            errors.append(f\"{property_name} not found in input properties\")\n            continue\n        \n        actual_value = properties[property_name]\n        \n        # Check type\n        if not isinstance(actual_value, eval(expected_format)):\n            errors.append(f\"{property_name} is not of type {expected_format}\")\n            continue\n        \n        # Check value\n        if actual_value != expected_value:\n            errors.append(f\"{property_name}: Expected {expected_value} but got {actual_value}\")\n    \n    if errors:\n        print(\"failed:\", \"; \".join(errors))\n    else:\n        print(\"ok\")"
    },
    {
        "properties_json_str": "{\n  \"JSON_File_Name\": \"test_defect_entry\",\n  \"properties\": {\n    \"freysoldt_correction\": {\n      \"description\": \"The Freysoldt correction applied to the defect entry, which accounts for electrostatic interactions in charged defect calculations.\",\n      \"format\": \"float\",\n      \"value\": \"0.00\"\n    },\n    \"potential_alignment_consistency\": {\n      \"description\": \"Consistency check for potential alignment data between different sources, ensuring that the potential alignment correction is applied consistently.\",\n      \"format\": \"np.allclose\",\n      \"value\": \"True\"\n    },\n    \"energy_difference\": {\n      \"description\": \"The energy difference between the defect supercell and the bulk supercell, used to calculate the defect formation energy.\",\n      \"format\": \"float\",\n      \"value\": \"calculated as def_entry.sc_entry.energy - bulk_entry.energy\"\n    }\n  }\n}",
        "question": "As a materials scientist, you are utilizing Pymatgen to write functions to calculate material properties. Here is what you need to do:\n- Calculate the following properties:\n    - `freysoldt_correction`: The Freysoldt correction applied to the defect entry, which accounts for electrostatic interactions in charged defect calculations. Format: float.\n    - `potential_alignment_consistency`: Consistency check for potential alignment data between different sources, ensuring that the potential alignment correction is applied consistently. Format: boolean (True if consistent).\n    - `energy_difference`: The energy difference between the defect supercell and the bulk supercell, used to calculate the defect formation energy. Format: float.\n\nIf you need to read files or generate data, please refer to the following instructions:\n- Read or Generate Data:\n    - Access the test directory at: `<path>tool_source_code/pymatgen-analysis-defects/tests/test_files/</path>`.\n    - Use the Pymatgen function to read the defect entries and plot data:\n      ```python\n      from collections import defaultdict\n      from pymatgen.io.vasp.outputs import Vasprun, Locpot\n      from pymatgen.analysis.defects.thermo import DefectEntry\n      from pymatgen.analysis.defects.core import PeriodicSite, Substitution\n      from pymatgen.core import Structure, Specie\n\n      def get_defect_entries_and_plot_data(test_dir):\n          data = defaultdict(dict)\n          root_dir = test_dir / \"Mg_Ga\"\n          for fold in root_dir.glob(\"./*\"):\n              if not fold.is_dir():\n                  continue\n              data[fold.name] = {\n                  \"vasprun\": Vasprun(fold / \"vasprun.xml.gz\"),\n                  \"locpot\": Locpot.from_file(fold / \"LOCPOT.gz\"),\n              }\n          bulk_locpot = data[\"bulk_sc\"][\"locpot\"]\n          gan_struct = Structure.from_file(test_dir / \"GaN.vasp\")\n          ga_site = gan_struct[0]\n          mg_site = PeriodicSite(Specie(\"Mg\"), ga_site.frac_coords, gan_struct.lattice)\n          defect_Mg_Ga = Substitution(gan_struct, mg_site)\n\n          def get_data(q):\n              computed_entry = data[f\"q={q}\"][\"vasprun\"].get_computed_entry(inc_structure=True)\n              defect_locpot = data[f\"q={q}\"][\"locpot\"]\n              def_entry = DefectEntry(defect=defect_Mg_Ga, charge_state=q, sc_entry=computed_entry)\n              frey_summary = def_entry.get_freysoldt_correction(\n                  defect_locpot=defect_locpot, bulk_locpot=bulk_locpot, dielectric=14\n              )\n              return def_entry, frey_summary\n\n          defect_entries = dict()\n          plot_data = dict()\n          for qq in [-2, -1, 0, 1]:\n              defect_entry, frey_summary = get_data(qq)\n              defect_entries[qq] = defect_entry\n              plot_data[qq] = frey_summary.metadata[\"plot_data\"]\n          return defect_entries, plot_data\n      ```\n\nAll content is executed within the function, and the function does not require any input to output the result. The format of the function should follow these guidelines:\n- Write a Python function that:\n    - Reads the data from the provided file paths or generate data based on the description in the first section.\n    - Calculates all the properties mentioned above using Pymatgen.\n    - Returns a dictionary where the property names are keys, and the calculated results are the values.\n\n- Ensure your function includes:\n    - Necessary imports (e.g., `from pymatgen.core import Structure`).\n    - Proper file handling or data generation code.\n    - Output in the form of a dictionary as specified above.\n    - A complete docstring with clear input parameters, data types, and a description of the output.\n\n**Write the required Python function for this task**.",
        "new_unit_test": "def test_test_defect_entry(properties):\n    import numpy as np\n    expected_properties = {\n        \"freysoldt_correction\": {\n            \"format\": \"float\",\n            \"value\": 0.00\n        },\n        \"potential_alignment_consistency\": {\n            \"format\": \"np.allclose\",\n            \"value\": True\n        },\n        \"energy_difference\": {\n            \"format\": \"float\",\n            \"value\": \"calculated as def_entry.sc_entry.energy - bulk_entry.energy\"\n        }\n    }\n    \n    errors = []\n    \n    for property_name, expected_info in expected_properties.items():\n        expected_value = expected_info['value']\n        expected_format = expected_info['format']\n        \n        if property_name not in properties:\n            errors.append(f\"{property_name} not found in input properties\")\n            continue\n        \n        actual_value = properties[property_name]\n        \n        # Check type (skip type check for np.allclose cases as it's handled separately)\n        if expected_format != \"np.allclose\" and not isinstance(actual_value, eval(expected_format)):\n            errors.append(f\"{property_name} is not of type {expected_format}\")\n            continue\n        \n        # Check value or use np.allclose for approximate comparisons\n        if expected_format == \"np.allclose\":\n            if not np.allclose([actual_value], [expected_value]):\n                errors.append(f\"{property_name}: Expected value close to {expected_value} but got {actual_value}\")\n        else:\n            if actual_value != expected_value:\n                errors.append(f\"{property_name}: Expected {expected_value} but got {actual_value}\")\n    \n    if errors:\n        print(\"failed:\", \"; \".join(errors))\n    else:\n        print(\"ok\")"
    },
    {
        "properties_json_str": "{\n  \"JSON_File_Name\": \"test_formation_energy_diagram_using_bulk_entry\",\n  \"properties\": {\n    \"chempot_limits_count\": {\n      \"description\": \"The number of chemical potential limits in the formation energy diagram, indicating the number of distinct chemical environments considered.\",\n      \"format\": \"int\",\n      \"value\": 3\n    },\n    \"defect_chemsys\": {\n      \"description\": \"The chemical system of the defects, represented as a string of element symbols separated by hyphens.\",\n      \"format\": \"str\",\n      \"value\": \"Ga-Mg-N\"\n    },\n    \"bulk_formula\": {\n      \"description\": \"The chemical formula of the bulk material used in the formation energy diagram.\",\n      \"format\": \"str\",\n      \"value\": \"GaN\"\n    }\n  }\n}",
        "question": "As a materials scientist, you are utilizing Pymatgen to write functions to calculate material properties. Here is what you need to do:\n- Calculate the following properties:\n    - `chempot_limits_count`: The number of chemical potential limits in the formation energy diagram, indicating the number of distinct chemical environments considered. The format is an integer.\n    - `defect_chemsys`: The chemical system of the defects, represented as a string of element symbols separated by hyphens. The format is a string.\n    - `bulk_formula`: The chemical formula of the bulk material used in the formation energy diagram. The format is a string.\n\nIf you need to read files or generate data, please refer to the following instructions:\n- Read or Generate Data:\n    - Access the structure file at: `<path>tool_source_code/pymatgen-analysis-defects/tests/test_files/GaN.vasp</path>`.\n    - Use the Pymatgen function ```python\\nfrom pymatgen.core import Structure\\nStructure.from_file(file_path / \"GaN.vasp\")\\n``` to read the structure data.\n    - Access the stable entries file at: `<path>tool_source_code/pymatgen-analysis-defects/tests/test_files/stable_entries_Mg_Ga_N.json</path>`.\n    - Use the Pymatgen function ```python\\nfrom monty.serialization import loadfn\\nloadfn(file_path / \"stable_entries_Mg_Ga_N.json\")\\n``` to read the stable entries data.\n    - Generate the formation energy diagram using the Pymatgen function: \n    ```python\n    from pymatgen.analysis.defects.thermo import FormationEnergyDiagram\n    from pymatgen.analysis.phase_diagram import PhaseDiagram\n    from pymatgen.core import Element\n    # Assume defect_entries and vbm are already defined\n    atomic_entries = list(filter(lambda x: len(x.composition.elements) == 1, stable_entries))\n    pd = PhaseDiagram(stable_entries)\n    fed = FormationEnergyDiagram.with_atomic_entries(\n        defect_entries=defect_entries,\n        atomic_entries=atomic_entries,\n        vbm=vbm,\n        inc_inf_values=False,\n        phase_diagram=pd,\n        bulk_entry=bulk_entry,\n    )\n    ```\n\nAll content is executed within the function, and the function does not require any input to output the result. The format of the function should follow these guidelines:\n- Write a Python function that:\n    - Reads the data from the provided file paths or generate data based on the description in the first section.\n    - Calculates all the properties mentioned above using Pymatgen.\n    - Returns a dictionary where the property names are keys, and the calculated results are the values.\n\n- Ensure your function includes:\n    - Necessary imports (e.g., `from pymatgen.core import Structure`).\n    - Proper file handling or data generation code.\n    - Output in the form of a dictionary as specified above.\n    - A complete docstring with clear input parameters, data types, and a description of the output.\n\n**Write the required Python function for this task**.",
        "new_unit_test": "def test_formation_energy_diagram_using_bulk_entry(properties):\n    import numpy as np\n    expected_properties = {\n        \"chempot_limits_count\": {\n            \"format\": \"int\",\n            \"value\": 3\n        },\n        \"defect_chemsys\": {\n            \"format\": \"str\",\n            \"value\": \"Ga-Mg-N\"\n        },\n        \"bulk_formula\": {\n            \"format\": \"str\",\n            \"value\": \"GaN\"\n        }\n    }\n    \n    errors = []\n    \n    for property_name, expected_info in expected_properties.items():\n        expected_value = expected_info['value']\n        expected_format = expected_info['format']\n        \n        if property_name not in properties:\n            errors.append(f\"{property_name} not found in input properties\")\n            continue\n        \n        actual_value = properties[property_name]\n        \n        # Check type (skip type check for np.allclose cases as it's handled separately)\n        if expected_format != \"np.allclose\" and not isinstance(actual_value, eval(expected_format)):\n            errors.append(f\"{property_name} is not of type {expected_format}\")\n            continue\n        \n        # Check value or use np.allclose for approximate comparisons\n        if expected_format == \"np.allclose\":\n            if not np.allclose(actual_value, expected_value):\n                errors.append(f\"{property_name}: Expected value close to {expected_value} but got {actual_value}\")\n        else:\n            if actual_value != expected_value:\n                errors.append(f\"{property_name}: Expected {expected_value} but got {actual_value}\")\n    \n    if errors:\n        print(\"failed:\", \"; \".join(errors))\n    else:\n        print(\"ok\")"
    },
    {
        "properties_json_str": "{\n  \"JSON_File_Name\": \"test_formation_energy_diagram_shape_fixed\",\n  \"properties\": {\n    \"formation_energy_diagram_x_coordinates\": {\n      \"description\": \"Ensures that the x-coordinates of the formation energy diagram remain consistent across different chemical potential limits.\",\n      \"format\": \"np.allclose (array of floats)\",\n      \"value\": \"[0.0, 1.0, 2.0, 3.0, 4.0]\"\n    },\n    \"formation_energy_diagram_y_coordinates\": {\n      \"description\": \"Ensures that the y-coordinates of the formation energy diagram, adjusted by their minimum value, remain consistent across different chemical potential limits.\",\n      \"format\": \"np.allclose (array of floats)\",\n      \"value\": \"[0.0, 0.5, 1.0, 1.5, 2.0]\"\n    }\n  }\n}",
        "question": "As a materials scientist, you are utilizing Pymatgen to write functions to calculate material properties. Here is what you need to do:\n- Calculate the following properties:\n    - `formation_energy_diagram_x_coordinates`: Ensures that the x-coordinates of the formation energy diagram remain consistent across different chemical potential limits. The format is `np.allclose (array of floats)`.\n    - `formation_energy_diagram_y_coordinates`: Ensures that the y-coordinates of the formation energy diagram, adjusted by their minimum value, remain consistent across different chemical potential limits. The format is `np.allclose (array of floats)`.\n\nIf you need to read files or generate data, please refer to the following instructions:\n- Read or Generate Data:\n    - Access the test directory at: `<path>tool_source_code/pymatgen-analysis-defects/tests/test_files/</path>`.\n    - Use the Pymatgen function to load the formation energy diagram:\n      ```python\n      from monty.serialization import loadfn\n      from pymatgen.analysis.defects.thermo import FormationEnergyDiagram\n      from pymatgen.analysis.phase_diagram import PhaseDiagram\n      from pymatgen.core import Element\n      from pymatgen.io.vasp.outputs import Vasprun\n\n      # Load necessary data\n      test_dir = Path('<path>tool_source_code/pymatgen-analysis-defects/tests/test_files/</path>')\n      stable_entries_Mg_Ga_N = loadfn(test_dir / \"stable_entries_Mg_Ga_N.json\")\n      data_Mg_Ga = defaultdict(dict)\n      root_dir = test_dir / \"Mg_Ga\"\n      for fold in root_dir.glob(\"./*\"):\n          if not fold.is_dir():\n              continue\n          data_Mg_Ga[fold.name] = {\n              \"vasprun\": Vasprun(fold / \"vasprun.xml.gz\"),\n              \"locpot\": Locpot.from_file(fold / \"LOCPOT.gz\"),\n          }\n      bulk_vasprun = data_Mg_Ga[\"bulk_sc\"][\"vasprun\"]\n      bulk_bs = bulk_vasprun.get_band_structure()\n      vbm = bulk_bs.get_vbm()[\"energy\"]\n      bulk_entry = bulk_vasprun.get_computed_entry(inc_structure=False)\n      defect_entries, _ = defect_entries_and_plot_data_Mg_Ga\n\n      def_ent_list = list(defect_entries.values())\n      atomic_entries = list(\n          filter(lambda x: len(x.composition.elements) == 1, stable_entries_Mg_Ga_N)\n      )\n      pd = PhaseDiagram(stable_entries_Mg_Ga_N)\n      fed = FormationEnergyDiagram.with_atomic_entries(\n          defect_entries=def_ent_list,\n          atomic_entries=atomic_entries,\n          vbm=vbm,\n          inc_inf_values=False,\n          phase_diagram=pd,\n          bulk_entry=bulk_entry,\n      )\n      ```\n\nAll content is executed within the function, and the function does not require any input to output the result. The format of the function should follow these guidelines:\n- Write a Python function that:\n    - Reads the data from the provided file paths or generate data based on the description in the first section.\n    - Calculates all the properties mentioned above using Pymatgen.\n    - Returns a dictionary where the property names are keys, and the calculated results are the values.\n\n- Ensure your function includes:\n    - Necessary imports (e.g., `from pymatgen.core import Structure`).\n    - Proper file handling or data generation code.\n    - Output in the form of a dictionary as specified above.\n    - A complete docstring with clear input parameters, data types, and a description of the output.\n\n**Write the required Python function for this task**.",
        "new_unit_test": "def test_formation_energy_diagram_shape_fixed(properties):\n    import numpy as np\n    expected_properties = {\n        \"formation_energy_diagram_x_coordinates\": {\n            \"format\": \"np.allclose\",\n            \"value\": np.array([0.0, 1.0, 2.0, 3.0, 4.0])\n        },\n        \"formation_energy_diagram_y_coordinates\": {\n            \"format\": \"np.allclose\",\n            \"value\": np.array([0.0, 0.5, 1.0, 1.5, 2.0])\n        }\n    }\n    \n    errors = []\n    \n    for property_name, expected_info in expected_properties.items():\n        expected_value = expected_info['value']\n        expected_format = expected_info['format']\n        \n        if property_name not in properties:\n            errors.append(f\"{property_name} not found in input properties\")\n            continue\n        \n        actual_value = properties[property_name]\n        \n        # Check value using np.allclose for approximate comparisons\n        if expected_format == \"np.allclose\":\n            if not np.allclose(actual_value, expected_value):\n                errors.append(f\"{property_name}: Expected value close to {expected_value} but got {actual_value}\")\n    \n    if errors:\n        print(\"failed:\", \"; \".join(errors))\n    else:\n        print(\"ok\")"
    },
    {
        "properties_json_str": "{\n  \"JSON_File_Name\": \"test_formation_energy_diagram_using_atomic_entries\",\n  \"properties\": {\n    \"chemical_potential_limits_count\": {\n      \"description\": \"The number of chemical potential limits in the formation energy diagram, indicating the number of distinct chemical environments considered.\",\n      \"format\": \"int\",\n      \"value\": 3\n    }\n  }\n}",
        "question": "As a materials scientist, you are utilizing Pymatgen to write functions to calculate material properties. Here is what you need to do:\n- Calculate the following properties:\n    - `chemical_potential_limits_count`: The number of chemical potential limits in the formation energy diagram, indicating the number of distinct chemical environments considered. The format is an integer.\n\nIf you need to read files or generate data, please refer to the following instructions:\n- Read or Generate Data:\n    - Access the stable entries file at: `<path>tool_source_code/pymatgen-analysis-defects/tests/test_files/stable_entries_Mg_Ga_N.json</path>`.\n    - Use the Pymatgen function ```python\\nfrom monty.serialization import loadfn\\nstable_entries = loadfn(file_path / \"stable_entries_Mg_Ga_N.json\")\\n``` to read the stable entries data.\n    - Access the defect entries and plot data for Mg_Ga at: `<path>tool_source_code/pymatgen-analysis-defects/tests/test_files/Mg_Ga</path>`.\n    - Use the Pymatgen function ```python\\nfrom pymatgen.io.vasp.outputs import Vasprun, Locpot\\nfrom collections import defaultdict\\ndef data_Mg_Ga(file_path):\\n    data = defaultdict(dict)\\n    for fold in file_path.glob(\"./*\"):\\n        if not fold.is_dir():\\n            continue\\n        data[fold.name] = {\\n            \"vasprun\": Vasprun(fold / \"vasprun.xml.gz\"),\\n            \"locpot\": Locpot.from_file(fold / \"LOCPOT.gz\"),\\n        }\\n    return data\\n``` to read the defect entries and plot data.\n    - Use the Pymatgen function ```python\\nfrom pymatgen.analysis.defects.thermo import DefectEntry\\nfrom pymatgen.analysis.phase_diagram import PhaseDiagram\\nfrom pymatgen.core import Element\\n\\ndef defect_entries_and_plot_data_Mg_Ga(data_Mg_Ga, defect_Mg_Ga):\\n    bulk_locpot = data_Mg_Ga[\"bulk_sc\"][\"locpot\"]\\n\\n    def get_data(q):\\n        computed_entry = data_Mg_Ga[f\"q={q}\"][\"vasprun\"].get_computed_entry(\\n            inc_structure=True\\n        )\\n        defect_locpot = data_Mg_Ga[f\"q={q}\"][\"locpot\"]\\n\\n        def_entry = DefectEntry(\\n            defect=defect_Mg_Ga, charge_state=q, sc_entry=computed_entry\\n        )\\n        frey_summary = def_entry.get_freysoldt_correction(\\n            defect_locpot=defect_locpot, bulk_locpot=bulk_locpot, dielectric=14\\n        )\\n        return def_entry, frey_summary\\n\\n    defect_entries = dict()\\n    plot_data = dict()\\n    for qq in [-2, -1, 0, 1]:\\n        defect_entry, frey_summary = get_data(qq)\\n        defect_entries[qq] = defect_entry\\n        plot_data[qq] = frey_summary.metadata[\"plot_data\"]\\n    return defect_entries, plot_data\\n``` to generate defect entries and plot data.\n    - Use the Pymatgen function ```python\\nfrom pymatgen.analysis.defects.thermo import FormationEnergyDiagram\\n\\ndef formation_energy_diagram(data_Mg_Ga, defect_entries_and_plot_data_Mg_Ga, stable_entries_Mg_Ga_N):\\n    bulk_vasprun = data_Mg_Ga[\"bulk_sc\"][\"vasprun\"]\\n    bulk_bs = bulk_vasprun.get_band_structure()\\n    vbm = bulk_bs.get_vbm()[\"energy\"]\\n    bulk_entry = bulk_vasprun.get_computed_entry(inc_structure=False)\\n    defect_entries, _ = defect_entries_and_plot_data_Mg_Ga\\n\\n    def_ent_list = list(defect_entries.values())\\n    atomic_entries = list(\\n        filter(lambda x: len(x.composition.elements) == 1, stable_entries_Mg_Ga_N)\\n    )\\n    pd = PhaseDiagram(stable_entries_Mg_Ga_N)\\n\\n    fed = FormationEnergyDiagram.with_atomic_entries(\\n        defect_entries=def_ent_list,\\n        atomic_entries=atomic_entries,\\n        vbm=vbm,\\n        inc_inf_values=False,\\n        phase_diagram=pd,\\n        bulk_entry=bulk_entry,\\n    )\\n    return fed\\n``` to generate the formation energy diagram.\n\nAll content is executed within the function, and the function does not require any input to output the result. The format of the function should follow these guidelines:\n- Write a Python function that:\n    - Reads the data from the provided file paths or generate data based on the description in the first section.\n    - Calculates all the properties mentioned above using Pymatgen.\n    - Returns a dictionary where the property names are keys, and the calculated results are the values.\n\n- Ensure your function includes:\n    - Necessary imports (e.g., `from pymatgen.core import Structure`).\n    - Proper file handling or data generation code.\n    - Output in the form of a dictionary as specified above.\n    - A complete docstring with clear input parameters, data types, and a description of the output.\n\n**Write the required Python function for this task**.",
        "new_unit_test": "def test_formation_energy_diagram_using_atomic_entries(properties):\n    import numpy as np\n    expected_properties = {\n        \"chemical_potential_limits_count\": {\n            \"format\": \"int\",\n            \"value\": 3\n        }\n    }\n    \n    errors = []\n    \n    for property_name, expected_info in expected_properties.items():\n        expected_value = expected_info['value']\n        expected_format = expected_info['format']\n        \n        if property_name not in properties:\n            errors.append(f\"{property_name} not found in input properties\")\n            continue\n        \n        actual_value = properties[property_name]\n        \n        # Check type (skip type check for np.allclose cases as it's handled separately)\n        if expected_format != \"np.allclose\" and not isinstance(actual_value, eval(expected_format)):\n            errors.append(f\"{property_name} is not of type {expected_format}\")\n            continue\n        \n        # Check value or use np.allclose for approximate comparisons\n        if expected_format == \"np.allclose\":\n            if not np.allclose(actual_value, expected_value):\n                errors.append(f\"{property_name}: Expected value close to {expected_value} but got {actual_value}\")\n        else:\n            if actual_value != expected_value:\n                errors.append(f\"{property_name}: Expected {expected_value} but got {actual_value}\")\n    \n    if errors:\n        print(\"failed:\", \"; \".join(errors))\n    else:\n        print(\"ok\")"
    },
    {
        "properties_json_str": "{\n  \"JSON_File_Name\": \"test_formation_energy_diagram_numerical\",\n  \"properties\": {\n    \"formation_energy\": {\n      \"description\": \"The energy required to form a defect in a material, calculated at a given Fermi level and chemical potential.\",\n      \"format\": \"float (using pytest.approx for approximate comparison)\",\n      \"value\": \"1\"\n    },\n    \"defect_concentration\": {\n      \"description\": \"The concentration of defects in a material at a specified Fermi level, chemical potentials, and temperature.\",\n      \"format\": \"float (using pytest.approx for approximate comparison)\",\n      \"value\": \"2 * 1.5875937551666035e-17\"\n    }\n  }\n}",
        "question": "As a materials scientist, you are utilizing Pymatgen to write functions to calculate material properties. Here is what you need to do:\n- Calculate the following properties:\n    - `formation_energy`: The energy required to form a defect in a material, calculated at a given Fermi level and chemical potential. The format should be a float, using `pytest.approx` for approximate comparison.\n    - `defect_concentration`: The concentration of defects in a material at a specified Fermi level, chemical potentials, and temperature. The format should be a float, using `pytest.approx` for approximate comparison.\n\nIf you need to read files or generate data, please refer to the following instructions:\n- Read or Generate Data:\n    - Access the structure file at: `<path>tool_source_code/pymatgen-analysis-defects/tests/test_files/Mg_Ga/bulk_sc/vasprun.xml.gz</path>`.\n    - Access the stable entries file at: `<path>tool_source_code/pymatgen-analysis-defects/tests/test_files/stable_entries_Mg_Ga_N.json</path>`.\n    - Use the Pymatgen function ```python\\nfrom pymatgen.io.vasp.outputs import Vasprun\\nbulk_vasprun = Vasprun(file_path / \"Mg_Ga/bulk_sc/vasprun.xml.gz\")\\n``` to read the bulk vasprun data.\n    - Use the Pymatgen function ```python\\nfrom monty.serialization import loadfn\\nstable_entries = loadfn(file_path / \"stable_entries_Mg_Ga_N.json\")\\n``` to read the stable entries data.\n    - Use the Pymatgen function ```python\\nfrom pymatgen.analysis.defects.thermo import FormationEnergyDiagram\\nfrom pymatgen.analysis.phase_diagram import PhaseDiagram\\nfrom pymatgen.core import Element\\nbulk_bs = bulk_vasprun.get_band_structure()\\nvbm = bulk_bs.get_vbm()[\"energy\"]\\nbulk_entry = bulk_vasprun.get_computed_entry(inc_structure=False)\\npd = PhaseDiagram(stable_entries)\\nfed = FormationEnergyDiagram.with_atomic_entries(defect_entries=def_ent_list, atomic_entries=atomic_entries, vbm=vbm, inc_inf_values=False, phase_diagram=pd, bulk_entry=bulk_entry)\\n``` to generate the FormationEnergyDiagram.\n\nAll content is executed within the function, and the function does not require any input to output the result. The format of the function should follow these guidelines:\n- Write a Python function that:\n    - Reads the data from the provided file paths or generate data based on the description in the first section.\n    - Calculates all the properties mentioned above using Pymatgen.\n    - Returns a dictionary where the property names are keys, and the calculated results are the values.\n\n- Ensure your function includes:\n    - Necessary imports (e.g., `from pymatgen.core import Structure`).\n    - Proper file handling or data generation code.\n    - Output in the form of a dictionary as specified above.\n    - A complete docstring with clear input parameters, data types, and a description of the output.\n\n**Write the required Python function for this task**.",
        "new_unit_test": "def test_formation_energy_diagram_numerical(properties):\n    import numpy as np\n    expected_properties = {\n        \"formation_energy\": {\n            \"format\": \"np.allclose\",\n            \"value\": 1.0\n        },\n        \"defect_concentration\": {\n            \"format\": \"np.allclose\",\n            \"value\": 2 * 1.5875937551666035e-17\n        }\n    }\n    \n    errors = []\n    \n    for property_name, expected_info in expected_properties.items():\n        expected_value = expected_info['value']\n        expected_format = expected_info['format']\n        \n        if property_name not in properties:\n            errors.append(f\"{property_name} not found in input properties\")\n            continue\n        \n        actual_value = properties[property_name]\n        \n        # Check value using np.allclose for approximate comparisons\n        if expected_format == \"np.allclose\":\n            if not np.allclose(actual_value, expected_value):\n                errors.append(f\"{property_name}: Expected value close to {expected_value} but got {actual_value}\")\n        else:\n            if actual_value != expected_value:\n                errors.append(f\"{property_name}: Expected {expected_value} but got {actual_value}\")\n    \n    if errors:\n        print(\"failed:\", \"; \".join(errors))\n    else:\n        print(\"ok\")"
    },
    {
        "properties_json_str": "{\n  \"JSON_File_Name\": \"test_competing_phases\",\n  \"properties\": {\n    \"competing_phases_at_chempot_limits\": {\n      \"description\": \"This property tests the set of competing phases at specific chemical potential limits in a formation energy diagram.\",\n      \"format\": \"dict\",\n      \"value\": {\n        \"Mg:-1.50,Ga:-1.75,N:0.00\": {\"N2\", \"Mg3N2\"},\n        \"Mg:-0.35,Ga:-0.03,N:-1.71\": {\"Mg2Ga5\", \"Mg3N2\"},\n        \"Mg:-0.44,Ga:0.00,N:-1.75\": {\"Mg2Ga5\", \"Ga\"}\n      }\n    }\n  }\n}",
        "question": "As a materials scientist, you are utilizing Pymatgen to write functions to calculate material properties. Here is what you need to do:\n- Calculate the following properties:\n    - `competing_phases_at_chempot_limits`: This property tests the set of competing phases at specific chemical potential limits in a formation energy diagram. The format is a dictionary where keys are strings representing chemical potential limits and values are sets of competing phase names.\n\nIf you need to read files or generate data, please refer to the following instructions:\n- Read or Generate Data:\n    - Access the stable entries file at: `<path>tool_source_code/pymatgen-analysis-defects/tests/test_files/stable_entries_Mg_Ga_N.json</path>`.\n    - Use the Pymatgen function ```python\\nfrom monty.serialization import loadfn\\nstable_entries = loadfn(file_path / \"stable_entries_Mg_Ga_N.json\")\\n``` to read the stable entries data.\n    - Access the defect data for Mg_Ga at: `<path>tool_source_code/pymatgen-analysis-defects/tests/test_files/Mg_Ga</path>`.\n    - Use the Pymatgen function ```python\\nfrom pymatgen.io.vasp.outputs import Vasprun, Locpot\\nfrom collections import defaultdict\\n\\ndef load_defect_data(root_dir):\\n    data = defaultdict(dict)\\n    for fold in root_dir.glob(\"./*\"):\\n        if not fold.is_dir():\\n            continue\\n        data[fold.name] = {\\n            \"vasprun\": Vasprun(fold / \"vasprun.xml.gz\"),\\n            \"locpot\": Locpot.from_file(fold / \"LOCPOT.gz\"),\\n        }\\n    return data\\n\\ndata_Mg_Ga = load_defect_data(file_path / \"Mg_Ga\")\\n``` to read the defect data.\n    - Generate the formation energy diagram using the defect entries and stable entries. You should use the Pymatgen function: ```python\\nfrom pymatgen.analysis.defects.thermo import FormationEnergyDiagram\\nfrom pymatgen.analysis.phase_diagram import PhaseDiagram\\n\\nbulk_vasprun = data_Mg_Ga[\"bulk_sc\"][\"vasprun\"]\\nbulk_bs = bulk_vasprun.get_band_structure()\\nvbm = bulk_bs.get_vbm()[\"energy\"]\\nbulk_entry = bulk_vasprun.get_computed_entry(inc_structure=False)\\n\\ndefect_entries = [data_Mg_Ga[f\"q={q}\"][\"vasprun\"].get_computed_entry(inc_structure=True) for q in [-2, -1, 0, 1]]\\natomic_entries = list(filter(lambda x: len(x.composition.elements) == 1, stable_entries))\\npd = PhaseDiagram(stable_entries)\\n\\nfed = FormationEnergyDiagram.with_atomic_entries(\\n    defect_entries=defect_entries,\\n    atomic_entries=atomic_entries,\\n    vbm=vbm,\\n    inc_inf_values=False,\\n    phase_diagram=pd,\\n    bulk_entry=bulk_entry,\\n)\\n```\n\nAll content is executed within the function, and the function does not require any input to output the result. The format of the function should follow these guidelines:\n- Write a Python function that:\n    - Reads the data from the provided file paths or generate data based on the description in the first section.\n    - Calculates all the properties mentioned above using Pymatgen.\n    - Returns a dictionary where the property names are keys, and the calculated results are the values.\n\n- Ensure your function includes:\n    - Necessary imports (e.g., `from pymatgen.analysis.defects.thermo import FormationEnergyDiagram`).\n    - Proper file handling or data generation code.\n    - Output in the form of a dictionary as specified above.\n    - A complete docstring with clear input parameters, data types, and a description of the output.\n\n**Write the required Python function for this task**.",
        "new_unit_test": "def test_competing_phases(properties):\n    import numpy as np\n    expected_properties = {\n        \"competing_phases_at_chempot_limits\": {\n            \"format\": \"dict\",\n            \"value\": {\n                \"Mg:-1.50,Ga:-1.75,N:0.00\": {\"N2\", \"Mg3N2\"},\n                \"Mg:-0.35,Ga:-0.03,N:-1.71\": {\"Mg2Ga5\", \"Mg3N2\"},\n                \"Mg:-0.44,Ga:0.00,N:-1.75\": {\"Mg2Ga5\", \"Ga\"}\n            }\n        }\n    }\n    \n    errors = []\n    \n    for property_name, expected_info in expected_properties.items():\n        expected_value = expected_info['value']\n        expected_format = expected_info['format']\n        \n        if property_name not in properties:\n            errors.append(f\"{property_name} not found in input properties\")\n            continue\n        \n        actual_value = properties[property_name]\n        \n        # Check type (skip type check for np.allclose cases as it's handled separately)\n        if expected_format != \"np.allclose\" and not isinstance(actual_value, eval(expected_format)):\n            errors.append(f\"{property_name} is not of type {expected_format}\")\n            continue\n        \n        # Check value or use np.allclose for approximate comparisons\n        if expected_format == \"np.allclose\":\n            if not np.allclose(actual_value, expected_value):\n                errors.append(f\"{property_name}: Expected value close to {expected_value} but got {actual_value}\")\n        else:\n            if actual_value != expected_value:\n                errors.append(f\"{property_name}: Expected {expected_value} but got {actual_value}\")\n    \n    if errors:\n        print(\"failed:\", \"; \".join(errors))\n    else:\n        print(\"ok\")"
    },
    {
        "properties_json_str": "{\n  \"JSON_File_Name\": \"test_multi\",\n  \"properties\": {\n    \"Fermi_Level_Solution\": {\n      \"description\": \"The Fermi level solution is calculated using the chemical potentials and density of states at a given temperature, ensuring it is greater than zero.\",\n      \"format\": \"float\",\n      \"value\": \"ef > 0\"\n    },\n    \"Formation_Energy_Diagrams_Count\": {\n      \"description\": \"The number of formation energy diagrams created using atomic entries and a phase diagram, ensuring the correct construction of the MultiFormationEnergyDiagram.\",\n      \"format\": \"int\",\n      \"value\": \"1\"\n    }\n  }\n}",
        "question": "As a materials scientist, you are utilizing Pymatgen to write functions to calculate material properties. Here is what you need to do:\n- Calculate the following properties:\n    - `Fermi_Level_Solution`: The Fermi level solution is calculated using the chemical potentials and density of states at a given temperature, ensuring it is greater than zero. The format is a float.\n    - `Formation_Energy_Diagrams_Count`: The number of formation energy diagrams created using atomic entries and a phase diagram, ensuring the correct construction of the MultiFormationEnergyDiagram. The format is an integer.\n\nIf you need to read files or generate data, please refer to the following instructions:\n- Read or Generate Data:\n    - Access the data files at: `<path>tool_source_code/pymatgen-analysis-defects/tests/test_files/</path>`.\n    - Use the Pymatgen function to read the necessary data:\n      ```python\n      from monty.serialization import loadfn\n      from pymatgen.io.vasp.outputs import Vasprun\n      from pymatgen.analysis.phase_diagram import PhaseDiagram\n      from pymatgen.core import Element\n\n      # Load stable entries\n      stable_entries_Mg_Ga_N = loadfn(file_path / \"stable_entries_Mg_Ga_N.json\")\n\n      # Load defect entries and plot data\n      data_Mg_Ga = defaultdict(dict)\n      root_dir = file_path / \"Mg_Ga\"\n      for fold in root_dir.glob(\"./*\"):\n          if not fold.is_dir():\n              continue\n          data_Mg_Ga[fold.name] = {\n              \"vasprun\": Vasprun(fold / \"vasprun.xml.gz\"),\n              \"locpot\": Locpot.from_file(fold / \"LOCPOT.gz\"),\n          }\n\n      # Extract necessary data\n      bulk_vasprun = data_Mg_Ga[\"bulk_sc\"][\"vasprun\"]\n      bulk_dos = bulk_vasprun.complete_dos\n      _, vbm = bulk_dos.get_cbm_vbm()\n      bulk_entry = bulk_vasprun.get_computed_entry(inc_structure=False)\n      defect_entries, plot_data = defect_entries_and_plot_data_Mg_Ga(data_Mg_Ga, defect_Mg_Ga)\n      def_ent_list = list(defect_entries.values())\n      atomic_entries = list(filter(lambda x: len(x.composition.elements) == 1, stable_entries_Mg_Ga_N))\n      pd = PhaseDiagram(stable_entries_Mg_Ga_N)\n      ```\n\nAll content is executed within the function, and the function does not require any input to output the result. The format of the function should follow these guidelines:\n- Write a Python function that:\n    - Reads the data from the provided file paths or generates data based on the description in the first section.\n    - Calculates all the properties mentioned above using Pymatgen.\n    - Returns a dictionary where the property names are keys, and the calculated results are the values.\n\n- Ensure your function includes:\n    - Necessary imports (e.g., `from pymatgen.core import Structure`).\n    - Proper file handling or data generation code.\n    - Output in the form of a dictionary as specified above.\n    - A complete docstring with clear input parameters, data types, and a description of the output.\n\n**Write the required Python function for this task**.",
        "new_unit_test": "def test_test_multi(properties):\n    import numpy as np\n    expected_properties = {\n        \"Fermi_Level_Solution\": {\n            \"format\": \"float\",\n            \"value\": \"ef > 0\"\n        },\n        \"Formation_Energy_Diagrams_Count\": {\n            \"format\": \"int\",\n            \"value\": 1\n        }\n    }\n    \n    errors = []\n    \n    for property_name, expected_info in expected_properties.items():\n        expected_value = expected_info['value']\n        expected_format = expected_info['format']\n        \n        if property_name not in properties:\n            errors.append(f\"{property_name} not found in input properties\")\n            continue\n        \n        actual_value = properties[property_name]\n        \n        # Check type (skip type check for np.allclose cases as it's handled separately)\n        if expected_format != \"np.allclose\" and not isinstance(actual_value, eval(expected_format)):\n            errors.append(f\"{property_name} is not of type {expected_format}\")\n            continue\n        \n        # Check value or use np.allclose for approximate comparisons\n        if property_name == \"Fermi_Level_Solution\":\n            # Special case for Fermi_Level_Solution to check if ef > 0\n            if not (isinstance(actual_value, float) and actual_value > 0):\n                errors.append(f\"{property_name}: Expected a float greater than 0 but got {actual_value}\")\n        else:\n            if actual_value != expected_value:\n                errors.append(f\"{property_name}: Expected {expected_value} but got {actual_value}\")\n    \n    if errors:\n        print(\"failed:\", \"; \".join(errors))\n    else:\n        print(\"ok\")"
    },
    {
        "properties_json_str": "{\n  \"JSON_File_Name\": \"test_formation_from_directory\",\n  \"properties\": {\n    \"directory_map_length\": {\n      \"description\": \"Checks that the directory map includes all charge states plus the bulk directory.\",\n      \"format\": \"int\",\n      \"value\": 4\n    },\n    \"transition_count\": {\n      \"description\": \"Verifies the number of transition states calculated in the formation energy diagram.\",\n      \"format\": \"int\",\n      \"value\": 4\n    }\n  }\n}",
        "question": "As a materials scientist, you are utilizing Pymatgen to write functions to calculate material properties. Here is what you need to do:\n- Calculate the following properties:\n    - `directory_map_length`: Checks that the directory map includes all charge states plus the bulk directory. The expected format is an integer.\n    - `transition_count`: Verifies the number of transition states calculated in the formation energy diagram. The expected format is an integer.\n\nIf you need to read files or generate data, please refer to the following instructions:\n- Read or Generate Data:\n    - Access the directory at: `<path>tool_source_code/pymatgen-analysis-defects/tests/test_files/Mg_Ga</path>`.\n    - Use the Pymatgen function to read the stable entries from the JSON file: \n      ```python\n      from monty.serialization import loadfn\n      stable_entries_Mg_Ga_N = loadfn(file_path / \"stable_entries_Mg_Ga_N.json\")\n      ```\n    - Access the structure file at: `<path>tool_source_code/pymatgen-analysis-defects/tests/test_files/GaN.vasp</path>`.\n    - Use the Pymatgen function to read the structure data:\n      ```python\n      from pymatgen.core import Structure\n      gan_struct = Structure.from_file(file_path / \"GaN.vasp\")\n      ```\n    - Generate the defect structure using:\n      ```python\n      from pymatgen.analysis.defects.core import PeriodicSite, Substitution\n      ga_site = gan_struct[0]\n      mg_site = PeriodicSite(Specie(\"Mg\"), ga_site.frac_coords, gan_struct.lattice)\n      defect_Mg_Ga = Substitution(gan_struct, mg_site)\n      ```\n    - Use the Pymatgen function to create a FormationEnergyDiagram:\n      ```python\n      from pymatgen.analysis.defects.thermo import FormationEnergyDiagram\n      dmap = {\"bulk\": sc_dir / \"bulk_sc\"}\n      dmap.update(zip([-1, 0, 1], map(lambda x: sc_dir / f\"q={x}\", [-1, 0, 1])))\n      fed = FormationEnergyDiagram.with_directories(\n          directory_map=dmap,\n          defect=defect_Mg_Ga,\n          pd_entries=stable_entries_Mg_Ga_N,\n          dielectric=10,\n      )\n      ```\n\nAll content is executed within the function, and the function does not require any input to output the result. The format of the function should follow these guidelines:\n- Write a Python function that:\n    - Reads the data from the provided file paths or generate data based on the description in the first section.\n    - Calculates all the properties mentioned above using Pymatgen.\n    - Returns a dictionary where the property names are keys, and the calculated results are the values.\n\n- Ensure your function includes:\n    - Necessary imports (e.g., `from pymatgen.core import Structure`).\n    - Proper file handling or data generation code.\n    - Output in the form of a dictionary as specified above.\n    - A complete docstring with clear input parameters, data types, and a description of the output.\n\n**Write the required Python function for this task**.",
        "new_unit_test": "def test_formation_from_directory(properties):\n    import numpy as np\n    expected_properties = {\n        \"directory_map_length\": {\n            \"format\": \"int\",\n            \"value\": 4\n        },\n        \"transition_count\": {\n            \"format\": \"int\",\n            \"value\": 4\n        }\n    }\n    \n    errors = []\n    \n    for property_name, expected_info in expected_properties.items():\n        expected_value = expected_info['value']\n        expected_format = expected_info['format']\n        \n        if property_name not in properties:\n            errors.append(f\"{property_name} not found in input properties\")\n            continue\n        \n        actual_value = properties[property_name]\n        \n        # Check type (skip type check for np.allclose cases as it's handled separately)\n        if expected_format != \"np.allclose\" and not isinstance(actual_value, eval(expected_format)):\n            errors.append(f\"{property_name} is not of type {expected_format}\")\n            continue\n        \n        # Check value or use np.allclose for approximate comparisons\n        if expected_format == \"np.allclose\":\n            if not np.allclose(actual_value, expected_value):\n                errors.append(f\"{property_name}: Expected value close to {expected_value} but got {actual_value}\")\n        else:\n            if actual_value != expected_value:\n                errors.append(f\"{property_name}: Expected {expected_value} but got {actual_value}\")\n    \n    if errors:\n        print(\"failed:\", \"; \".join(errors))\n    else:\n        print(\"ok\")"
    },
    {
        "properties_json_str": "{\n  \"JSON_File_Name\": \"test_ensure_stable_bulk\",\n  \"properties\": {\n    \"GaN_stability_in_phase_diagram\": {\n      \"description\": \"Checks if the compound GaN is included in the stable entries of a phase diagram after ensuring stability.\",\n      \"format\": \"bool\",\n      \"value\": \"True\"\n    }\n  }\n}",
        "question": "As a materials scientist, you are utilizing Pymatgen to write functions to calculate material properties. Here is what you need to do:\n- Calculate the following properties:\n    - `GaN_stability_in_phase_diagram`: Checks if the compound GaN is included in the stable entries of a phase diagram after ensuring stability. The format is a boolean.\n\nIf you need to read files or generate data, please refer to the following instructions:\n- Read or Generate Data:\n    - Access the stable entries data at: `<path>tool_source_code/pymatgen-analysis-defects/tests/test_files/stable_entries_Mg_Ga_N.json</path>`.\n    - Use the Pymatgen function ```python\\nfrom monty.serialization import loadfn\\nfrom pymatgen.analysis.phase_diagram import PhaseDiagram\\nentries = loadfn(file_path / \"stable_entries_Mg_Ga_N.json\")\\n``` to read the stable entries data.\n    - Generate a phase diagram using the Pymatgen function: ```python\\npd = PhaseDiagram(entries)\\n```.\n    - Create a composition for GaN using Pymatgen: ```python\\nfrom pymatgen.analysis.defects.thermo import Composition\\nbulk_comp = Composition(\"GaN\")\\n```.\n    - Create a computed entry for GaN using Pymatgen: ```python\\nfrom pymatgen.analysis.defects.thermo import ComputedEntry\\nfake_bulk_ent = ComputedEntry(bulk_comp, energy=pd.get_hull_energy(bulk_comp) + 2)\\n```.\n    - Ensure GaN stability in the phase diagram using Pymatgen: ```python\\nfrom pymatgen.analysis.defects.thermo import ensure_stable_bulk\\npd2 = ensure_stable_bulk(pd, fake_bulk_ent)\\n```.\n    - Check if GaN is in the stable entries: ```python\\n\"GaN\" in [e.composition.reduced_formula for e in pd2.stable_entries]\\n```.\n\nAll content is executed within the function, and the function does not require any input to output the result. The format of the function should follow these guidelines:\n- Write a Python function that:\n    - Reads the data from the provided file paths or generate data based on the description in the first section.\n    - Calculates all the properties mentioned above using Pymatgen.\n    - Returns a dictionary where the property names are keys, and the calculated results are the values.\n\n- Ensure your function includes:\n    - Necessary imports (e.g., `from pymatgen.analysis.phase_diagram import PhaseDiagram`).\n    - Proper file handling or data generation code.\n    - Output in the form of a dictionary as specified above.\n    - A complete docstring with clear input parameters, data types, and a description of the output.\n\n**Write the required Python function for this task**.",
        "new_unit_test": "def test_ensure_stable_bulk(properties):\n    import numpy as np\n    expected_properties = {\n        \"GaN_stability_in_phase_diagram\": {\n            \"format\": \"bool\",\n            \"value\": True\n        }\n    }\n    \n    errors = []\n    \n    for property_name, expected_info in expected_properties.items():\n        expected_value = expected_info['value']\n        expected_format = expected_info['format']\n        \n        if property_name not in properties:\n            errors.append(f\"{property_name} not found in input properties\")\n            continue\n        \n        actual_value = properties[property_name]\n        \n        # Check type (skip type check for np.allclose cases as it's handled separately)\n        if expected_format != \"np.allclose\" and not isinstance(actual_value, eval(expected_format)):\n            errors.append(f\"{property_name} is not of type {expected_format}\")\n            continue\n        \n        # Check value or use np.allclose for approximate comparisons\n        if expected_format == \"np.allclose\":\n            if not np.allclose(actual_value, expected_value):\n                errors.append(f\"{property_name}: Expected value close to {expected_value} but got {actual_value}\")\n        else:\n            if actual_value != expected_value:\n                errors.append(f\"{property_name}: Expected {expected_value} but got {actual_value}\")\n    \n    if errors:\n        print(\"failed:\", \"; \".join(errors))\n    else:\n        print(\"ok\")"
    },
    {
        "properties_json_str": "{\n  \"JSON_File_Name\": \"test_plotter\",\n  \"properties\": {\n    \"band_gap_specification\": {\n      \"description\": \"Ensures that a band gap value is specified for plotting formation energy diagrams.\",\n      \"format\": \"float\",\n      \"value\": 1.0\n    },\n    \"xlim_specification\": {\n      \"description\": \"Specifies the x-axis limits for the formation energy diagram plot.\",\n      \"format\": \"list\",\n      \"value\": [0, 2]\n    },\n    \"ylim_specification\": {\n      \"description\": \"Specifies the y-axis limits for the formation energy diagram plot.\",\n      \"format\": \"list\",\n      \"value\": [0, 4]\n    },\n    \"chempot_limits\": {\n      \"description\": \"Chemical potential limits used for plotting the formation energy diagrams.\",\n      \"format\": \"list\",\n      \"value\": \"fed.chempot_limits[0]\"\n    },\n    \"only_lower_envelope\": {\n      \"description\": \"Determines whether to plot only the lower envelope of the formation energy diagram.\",\n      \"format\": \"bool\",\n      \"value\": false\n    },\n    \"legend_prefix\": {\n      \"description\": \"Prefix for the legend in the formation energy diagram plot.\",\n      \"format\": \"str\",\n      \"value\": \"test\"\n    },\n    \"linestyle\": {\n      \"description\": \"Line style used in the formation energy diagram plot.\",\n      \"format\": \"str\",\n      \"value\": \"--\"\n    },\n    \"line_alpha\": {\n      \"description\": \"Transparency level of the lines in the formation energy diagram plot.\",\n      \"format\": \"float\",\n      \"value\": 1.0\n    },\n    \"linewidth\": {\n      \"description\": \"Width of the lines in the formation energy diagram plot.\",\n      \"format\": \"int\",\n      \"value\": 1\n    }\n  }\n}",
        "question": "As a materials scientist, you are utilizing Pymatgen to write functions to calculate material properties. Here is what you need to do:\n- Calculate the following properties:\n    - `band_gap_specification`: Ensures that a band gap value is specified for plotting formation energy diagrams. Format: float.\n    - `xlim_specification`: Specifies the x-axis limits for the formation energy diagram plot. Format: list.\n    - `ylim_specification`: Specifies the y-axis limits for the formation energy diagram plot. Format: list.\n    - `chempot_limits`: Chemical potential limits used for plotting the formation energy diagrams. Format: list.\n    - `only_lower_envelope`: Determines whether to plot only the lower envelope of the formation energy diagram. Format: bool.\n    - `legend_prefix`: Prefix for the legend in the formation energy diagram plot. Format: str.\n    - `linestyle`: Line style used in the formation energy diagram plot. Format: str.\n    - `line_alpha`: Transparency level of the lines in the formation energy diagram plot. Format: float.\n    - `linewidth`: Width of the lines in the formation energy diagram plot. Format: int.\n\nIf you need to read files or generate data, please refer to the following instructions:\n- Read or Generate Data:\n    - Access the structure file at: `<path>tool_source_code/pymatgen-analysis-defects/tests/test_files/Mg_Ga/bulk_sc/vasprun.xml.gz</path>`.\n    - Use the Pymatgen function ```python\\nfrom pymatgen.io.vasp.outputs import Vasprun\\nbulk_vasprun = Vasprun(file_path / \"Mg_Ga/bulk_sc/vasprun.xml.gz\")\\n``` to read the vasprun data.\n    - Access the stable entries file at: `<path>tool_source_code/pymatgen-analysis-defects/tests/test_files/stable_entries_Mg_Ga_N.json</path>`.\n    - Use the Pymatgen function ```python\\nfrom monty.serialization import loadfn\\nstable_entries = loadfn(file_path / \"stable_entries_Mg_Ga_N.json\")\\n``` to read the stable entries data.\n    - Access the defect entries and plot data using the function `defect_entries_and_plot_data_Mg_Ga`.\n\nAll content is executed within the function, and the function does not require any input to output the result. The format of the function should follow these guidelines:\n- Write a Python function that:\n    - Reads the data from the provided file paths or generate data based on the description in the first section.\n    - Calculates all the properties mentioned above using Pymatgen.\n    - Returns a dictionary where the property names are keys, and the calculated results are the values.\n\n- Ensure your function includes:\n    - Necessary imports (e.g., `from pymatgen.io.vasp.outputs import Vasprun`).\n    - Proper file handling or data generation code.\n    - Output in the form of a dictionary as specified above.\n    - A complete docstring with clear input parameters, data types, and a description of the output.\n\n**Write the required Python function for this task**.",
        "new_unit_test": "def test_test_plotter(properties):\n    import numpy as np\n    expected_properties = {\n        \"band_gap_specification\": {\n            \"format\": \"float\",\n            \"value\": 1.0\n        },\n        \"xlim_specification\": {\n            \"format\": \"list\",\n            \"value\": [0, 2]\n        },\n        \"ylim_specification\": {\n            \"format\": \"list\",\n            \"value\": [0, 4]\n        },\n        \"chempot_limits\": {\n            \"format\": \"list\",\n            \"value\": \"fed.chempot_limits[0]\"\n        },\n        \"only_lower_envelope\": {\n            \"format\": \"bool\",\n            \"value\": False\n        },\n        \"legend_prefix\": {\n            \"format\": \"str\",\n            \"value\": \"test\"\n        },\n        \"linestyle\": {\n            \"format\": \"str\",\n            \"value\": \"--\"\n        },\n        \"line_alpha\": {\n            \"format\": \"float\",\n            \"value\": 1.0\n        },\n        \"linewidth\": {\n            \"format\": \"int\",\n            \"value\": 1\n        }\n    }\n    \n    errors = []\n    \n    for property_name, expected_info in expected_properties.items():\n        expected_value = expected_info['value']\n        expected_format = expected_info['format']\n        \n        if property_name not in properties:\n            errors.append(f\"{property_name} not found in input properties\")\n            continue\n        \n        actual_value = properties[property_name]\n        \n        # Check type (skip type check for np.allclose cases as it's handled separately)\n        if expected_format != \"np.allclose\" and not isinstance(actual_value, eval(expected_format)):\n            errors.append(f\"{property_name} is not of type {expected_format}\")\n            continue\n        \n        # Check value or use np.allclose for approximate comparisons\n        if expected_format == \"np.allclose\":\n            if not np.allclose(actual_value, expected_value):\n                errors.append(f\"{property_name}: Expected value close to {expected_value} but got {actual_value}\")\n        else:\n            if actual_value != expected_value:\n                errors.append(f\"{property_name}: Expected {expected_value} but got {actual_value}\")\n    \n    if errors:\n        print(\"failed:\", \"; \".join(errors))\n    else:\n        print(\"ok\")"
    },
    {
        "properties_json_str": "{\n  \"JSON_File_Name\": \"test_defect_entry_grouping\",\n  \"properties\": {\n    \"defect_name_consistency\": {\n      \"description\": \"Ensures that all defect entries in a group have the same defect name, indicating consistent grouping of defects.\",\n      \"format\": \"bool\",\n      \"value\": \"True\"\n    }\n  }\n}",
        "question": "As a materials scientist, you are utilizing Pymatgen to write functions to calculate material properties. Here is what you need to do:\n- Calculate the following properties:\n    - `defect_name_consistency`: Ensures that all defect entries in a group have the same defect name, indicating consistent grouping of defects. The format is a boolean.\n\nIf you need to read files or generate data, please refer to the following instructions:\n- Read or Generate Data:\n    - Access the structure file at: `<path>tool_source_code/pymatgen-analysis-defects/tests/test_files/GaN.vasp</path>`.\n    - Use the Pymatgen function:\n    ```python\n    from pymatgen.core import Structure\n    gan_struct = Structure.from_file(file_path / \"GaN.vasp\")\n    ```\n    - Access the defect entries and plot data for Mg_Ga from the directory: `<path>tool_source_code/pymatgen-analysis-defects/tests/test_files/Mg_Ga</path>`.\n    - Use the Pymatgen function:\n    ```python\n    from collections import defaultdict\n    from pymatgen.io.vasp.outputs import Vasprun, Locpot\n    from pymatgen.analysis.defects.thermo import DefectEntry\n    from pymatgen.analysis.defects.core import Substitution, PeriodicSite\n    from pymatgen.core.periodic_table import Specie\n\n    def load_defect_entries_and_plot_data(test_dir):\n        data = defaultdict(dict)\n        for fold in test_dir.glob(\"./*\"):\n            if not fold.is_dir():\n                continue\n            data[fold.name] = {\n                \"vasprun\": Vasprun(fold / \"vasprun.xml.gz\"),\n                \"locpot\": Locpot.from_file(fold / \"LOCPOT.gz\"),\n            }\n        bulk_locpot = data[\"bulk_sc\"][\"locpot\"]\n        defect_entries = dict()\n        plot_data = dict()\n        for qq in [-2, -1, 0, 1]:\n            computed_entry = data[f\"q={qq}\"][\"vasprun\"].get_computed_entry(inc_structure=True)\n            defect_locpot = data[f\"q={qq}\"][\"locpot\"]\n            ga_site = gan_struct[0]\n            mg_site = PeriodicSite(Specie(\"Mg\"), ga_site.frac_coords, gan_struct.lattice)\n            defect_Mg_Ga = Substitution(gan_struct, mg_site)\n            def_entry = DefectEntry(defect=defect_Mg_Ga, charge_state=qq, sc_entry=computed_entry)\n            frey_summary = def_entry.get_freysoldt_correction(defect_locpot=defect_locpot, bulk_locpot=bulk_locpot, dielectric=14)\n            defect_entries[qq] = def_entry\n            plot_data[qq] = frey_summary.metadata[\"plot_data\"]\n        return defect_entries, plot_data\n    ```\n\nAll content is executed within the function, and the function does not require any input to output the result. The format of the function should follow these guidelines:\n- Write a Python function that:\n    - Reads the data from the provided file paths or generate data based on the description in the first section.\n    - Calculates all the properties mentioned above using Pymatgen.\n    - Returns a dictionary where the property names are keys, and the calculated results are the values.\n\n- Ensure your function includes:\n    - Necessary imports (e.g., `from pymatgen.core import Structure`).\n    - Proper file handling or data generation code.\n    - Output in the form of a dictionary as specified above.\n    - A complete docstring with clear input parameters, data types, and a description of the output.\n\n**Write the required Python function for this task**.",
        "new_unit_test": "def test_test_defect_entry_grouping(properties):\n    import numpy as np\n    expected_properties = {\n        \"defect_name_consistency\": {\n            \"format\": \"bool\",\n            \"value\": True\n        }\n    }\n    \n    errors = []\n    \n    for property_name, expected_info in expected_properties.items():\n        expected_value = expected_info['value']\n        expected_format = expected_info['format']\n        \n        if property_name not in properties:\n            errors.append(f\"{property_name} not found in input properties\")\n            continue\n        \n        actual_value = properties[property_name]\n        \n        # Check type (skip type check for np.allclose cases as it's handled separately)\n        if expected_format != \"np.allclose\" and not isinstance(actual_value, eval(expected_format)):\n            errors.append(f\"{property_name} is not of type {expected_format}\")\n            continue\n        \n        # Check value or use np.allclose for approximate comparisons\n        if expected_format == \"np.allclose\":\n            if not np.allclose(actual_value, expected_value):\n                errors.append(f\"{property_name}: Expected value close to {expected_value} but got {actual_value}\")\n        else:\n            if actual_value != expected_value:\n                errors.append(f\"{property_name}: Expected {expected_value} but got {actual_value}\")\n    \n    if errors:\n        print(\"failed:\", \"; \".join(errors))\n    else:\n        print(\"ok\")"
    },
    {
        "properties_json_str": "{\n  \"JSON_File_Name\": \"test_defect_finder\",\n  \"properties\": {\n    \"vacancy_defect_distance\": {\n      \"description\": \"Distance between the guessed and actual fractional position of a vacancy defect in a supercell.\",\n      \"format\": \"float\",\n      \"value\": \"0.4\"\n    },\n    \"interstitial_defect_distance\": {\n      \"description\": \"Distance between the guessed and actual fractional position of an interstitial defect in a supercell.\",\n      \"format\": \"float\",\n      \"value\": \"0.3\"\n    },\n    \"anti_site_defect_distance\": {\n      \"description\": \"Distance between the guessed and actual fractional position of an anti-site defect in a supercell.\",\n      \"format\": \"float\",\n      \"value\": \"0.4\"\n    },\n    \"anti_site_initial_distance\": {\n      \"description\": \"Initial distance between two sites before creating an anti-site defect by swapping them.\",\n      \"format\": \"float\",\n      \"value\": \"1.5\"\n    }\n  }\n}",
        "question": "As a materials scientist, you are utilizing Pymatgen to write functions to calculate material properties. Here is what you need to do:\n- Calculate the following properties:\n    - `vacancy_defect_distance`: Distance between the guessed and actual fractional position of a vacancy defect in a supercell. (float)\n    - `interstitial_defect_distance`: Distance between the guessed and actual fractional position of an interstitial defect in a supercell. (float)\n    - `anti_site_defect_distance`: Distance between the guessed and actual fractional position of an anti-site defect in a supercell. (float)\n    - `anti_site_initial_distance`: Initial distance between two sites before creating an anti-site defect by swapping them. (float)\n\nIf you need to read files or generate data, please refer to the following instructions:\n- Read or Generate Data:\n    - Access the structure file at: `<path>tool_source_code/pymatgen-analysis-defects/tests/test_files/GaN.vasp</path>`.\n    - Use the Pymatgen function:\n    ```python\n    from pymatgen.core import IStructure\n    IStructure.from_file(file_path / \"GaN.vasp\")\n    ```\n    to read the structure data.\n\nAll content is executed within the function, and the function does not require any input to output the result. The format of the function should follow these guidelines:\n- Write a Python function that:\n    - Reads the data from the provided file paths or generate data based on the description in the first section.\n    - Calculates all the properties mentioned above using Pymatgen.\n    - Returns a dictionary where the property names are keys, and the calculated results are the values.\n\n- Ensure your function includes:\n    - Necessary imports (e.g., `from pymatgen.core import IStructure`).\n    - Proper file handling or data generation code.\n    - Output in the form of a dictionary as specified above.\n    - A complete docstring with clear input parameters, data types, and a description of the output.\n\n**Write the required Python function for this task**.",
        "new_unit_test": "def test_defect_finder(properties):\n    import numpy as np\n    expected_properties = {\n        \"vacancy_defect_distance\": {\n            \"format\": \"float\",\n            \"value\": 0.4\n        },\n        \"interstitial_defect_distance\": {\n            \"format\": \"float\",\n            \"value\": 0.3\n        },\n        \"anti_site_defect_distance\": {\n            \"format\": \"float\",\n            \"value\": 0.4\n        },\n        \"anti_site_initial_distance\": {\n            \"format\": \"float\",\n            \"value\": 1.5\n        }\n    }\n    \n    errors = []\n    \n    for property_name, expected_info in expected_properties.items():\n        expected_value = expected_info['value']\n        expected_format = expected_info['format']\n        \n        if property_name not in properties:\n            errors.append(f\"{property_name} not found in input properties\")\n            continue\n        \n        actual_value = properties[property_name]\n        \n        # Check type\n        if not isinstance(actual_value, eval(expected_format)):\n            errors.append(f\"{property_name} is not of type {expected_format}\")\n            continue\n        \n        # Check value\n        if actual_value != expected_value:\n            errors.append(f\"{property_name}: Expected {expected_value} but got {actual_value}\")\n    \n    if errors:\n        print(\"failed:\", \"; \".join(errors))\n    else:\n        print(\"ok\")"
    },
    {
        "properties_json_str": "{\n  \"JSON_File_Name\": \"test_defect_band_raises\",\n  \"properties\": {\n    \"defect_band_index_mismatch\": {\n      \"description\": \"Checks if a ValueError is raised when the defect band indices are mismatched.\",\n      \"format\": \"bool\",\n      \"value\": \"Raises ValueError\"\n    },\n    \"defect_spin_index_mismatch\": {\n      \"description\": \"Checks if a ValueError is raised when the defect spin indices are mismatched.\",\n      \"format\": \"bool\",\n      \"value\": \"Raises ValueError\"\n    }\n  }\n}",
        "question": "As a materials scientist, you are utilizing Pymatgen to write functions to calculate material properties. Here is what you need to do:\n- Calculate the following properties:\n    - `defect_band_index_mismatch`: Checks if a ValueError is raised when the defect band indices are mismatched. The format is a boolean indicating if the ValueError is raised.\n    - `defect_spin_index_mismatch`: Checks if a ValueError is raised when the defect spin indices are mismatched. The format is a boolean indicating if the ValueError is raised.\n\nIf you need to read files or generate data, please refer to the following instructions:\n- Read or Generate Data:\n    - Access the directory containing VASP output files at: `<path>tool_source_code/pymatgen-analysis-defects/tests/test_files/v_Ga/ccd_0_-1</path>`.\n    - Use the Pymatgen function to read the VASP run data and PROCAR file:\n      ```python\n      from pymatgen.io.vasp.outputs import Vasprun, Procar\n      vaspruns = [Vasprun(file_path / f\"{i}/vasprun.xml\") for i in [0, 1, 2]]\n      procar = Procar(file_path / \"1/PROCAR\")\n      ```\n    - Create a `HarmonicDefect` object using:\n      ```python\n      from pymatgen.analysis.defects.ccd import HarmonicDefect\n      hd0 = HarmonicDefect.from_vaspruns(vaspruns, charge_state=0, procar=procar, store_bandstructure=True)\n      ```\n\nAll content is executed within the function, and the function does not require any input to output the result. The format of the function should follow these guidelines:\n- Write a Python function that:\n    - Reads the data from the provided file paths or generates data based on the description in the first section.\n    - Calculates all the properties mentioned above using Pymatgen.\n    - Returns a dictionary where the property names are keys, and the calculated results are the values.\n\n- Ensure your function includes:\n    - Necessary imports (e.g., `from pymatgen.io.vasp.outputs import Vasprun, Procar`).\n    - Proper file handling or data generation code.\n    - Output in the form of a dictionary as specified above.\n    - A complete docstring with clear input parameters, data types, and a description of the output.\n\n**Write the required Python function for this task**.",
        "new_unit_test": "def test_defect_band_raises(properties):\n    expected_properties = {\n        \"defect_band_index_mismatch\": {\n            \"format\": \"bool\",\n            \"value\": \"Raises ValueError\"\n        },\n        \"defect_spin_index_mismatch\": {\n            \"format\": \"bool\",\n            \"value\": \"Raises ValueError\"\n        }\n    }\n    \n    errors = []\n    \n    for property_name, expected_info in expected_properties.items():\n        expected_value = expected_info['value']\n        expected_format = expected_info['format']\n        \n        if property_name not in properties:\n            errors.append(f\"{property_name} not found in input properties\")\n            continue\n        \n        actual_value = properties[property_name]\n        \n        # Check type (skip type check for np.allclose cases as it's handled separately)\n        if expected_format != \"np.allclose\" and not isinstance(actual_value, eval(expected_format)):\n            errors.append(f\"{property_name} is not of type {expected_format}\")\n            continue\n        \n        # Check value or use np.allclose for approximate comparisons\n        if expected_format == \"np.allclose\":\n            if not np.allclose(actual_value, expected_value):\n                errors.append(f\"{property_name}: Expected value close to {expected_value} but got {actual_value}\")\n        else:\n            if actual_value != expected_value:\n                errors.append(f\"{property_name}: Expected {expected_value} but got {actual_value}\")\n    \n    if errors:\n        print(\"failed:\", \"; \".join(errors))\n    else:\n        print(\"ok\")"
    },
    {
        "properties_json_str": "{\n  \"JSON_File_Name\": \"test_HarmonicDefect\",\n  \"properties\": {\n    \"defect_band_initial\": {\n      \"description\": \"The defect band structure for a harmonic defect, represented as a list of tuples indicating band index, spin, and occupancy.\",\n      \"format\": \"list of tuples\",\n      \"value\": \"[(138, 0, 1), (138, 1, 1)]\"\n    },\n    \"defect_band_from_directories\": {\n      \"description\": \"The defect band structure obtained from directories, confirming consistency with initial defect band structure.\",\n      \"format\": \"list of tuples\",\n      \"value\": \"[(138, 0, 1), (138, 1, 1)]\"\n    },\n    \"spin_index\": {\n      \"description\": \"The spin index of the defect band, indicating the spin channel being considered.\",\n      \"format\": \"int\",\n      \"value\": \"1\"\n    },\n    \"non_unique_spin_error\": {\n      \"description\": \"Error raised when the defect band has non-unique spin indices, ensuring spin consistency.\",\n      \"format\": \"bool\",\n      \"value\": \"True\"\n    }\n  }\n}",
        "question": "As a materials scientist, you are utilizing Pymatgen to write functions to calculate material properties. Here is what you need to do:\n- Calculate the following properties:\n    - `defect_band_initial`: The defect band structure for a harmonic defect, represented as a list of tuples indicating band index, spin, and occupancy. Format: list of tuples.\n    - `defect_band_from_directories`: The defect band structure obtained from directories, confirming consistency with initial defect band structure. Format: list of tuples.\n    - `spin_index`: The spin index of the defect band, indicating the spin channel being considered. Format: int.\n    - `non_unique_spin_error`: Error raised when the defect band has non-unique spin indices, ensuring spin consistency. Format: bool.\n\nIf you need to read files or generate data, please refer to the following instructions:\n- Read or Generate Data:\n    - Access the test directory at: `<path>tool_source_code/pymatgen-analysis-defects/tests/test_files/</path>`.\n    - Use the Pymatgen function to read the necessary data:\n      ```python\n      from pymatgen.io.vasp.outputs import Vasprun, Procar\n      from pymatgen.analysis.defects.ccd import HarmonicDefect\n      from pathlib import Path\n\n      test_dir = Path.cwd() / 'tool_source_code/pymatgen-analysis-defects/tests/test_files/'\n      ccd_dir = test_dir / \"v_Ga/ccd_0_-1\"\n      vaspruns = [Vasprun(ccd_dir / f\"{i}/vasprun.xml\") for i in [0, 1, 2]]\n      procar = Procar(ccd_dir / \"1/PROCAR\")\n      hd0 = HarmonicDefect.from_vaspruns(\n          vaspruns,\n          charge_state=0,\n          procar=procar,\n          store_bandstructure=True,\n      )\n      ```\n\nAll content is executed within the function, and the function does not require any input to output the result. The format of the function should follow these guidelines:\n- Write a Python function that:\n    - Reads the data from the provided file paths or generate data based on the description in the first section.\n    - Calculates all the properties mentioned above using Pymatgen.\n    - Returns a dictionary where the property names are keys, and the calculated results are the values.\n\n- Ensure your function includes:\n    - Necessary imports (e.g., `from pymatgen.io.vasp.outputs import Vasprun`).\n    - Proper file handling or data generation code.\n    - Output in the form of a dictionary as specified above.\n    - A complete docstring with clear input parameters, data types, and a description of the output.\n\n**Write the required Python function for this task**.",
        "new_unit_test": "def test_HarmonicDefect(properties):\n    import numpy as np\n    expected_properties = {\n        \"defect_band_initial\": {\n            \"format\": \"list of tuples\",\n            \"value\": [(138, 0, 1), (138, 1, 1)]\n        },\n        \"defect_band_from_directories\": {\n            \"format\": \"list of tuples\",\n            \"value\": [(138, 0, 1), (138, 1, 1)]\n        },\n        \"spin_index\": {\n            \"format\": \"int\",\n            \"value\": 1\n        },\n        \"non_unique_spin_error\": {\n            \"format\": \"bool\",\n            \"value\": True\n        }\n    }\n    \n    errors = []\n    \n    for property_name, expected_info in expected_properties.items():\n        expected_value = expected_info['value']\n        expected_format = expected_info['format']\n        \n        if property_name not in properties:\n            errors.append(f\"{property_name} not found in input properties\")\n            continue\n        \n        actual_value = properties[property_name]\n        \n        # Check type (skip type check for np.allclose cases as it's handled separately)\n        if expected_format != \"np.allclose\" and not isinstance(actual_value, eval(expected_format.replace(' of ', ''))):\n            errors.append(f\"{property_name} is not of type {expected_format}\")\n            continue\n        \n        # Check value or use np.allclose for approximate comparisons\n        if expected_format == \"np.allclose\":\n            if not np.allclose(actual_value, expected_value):\n                errors.append(f\"{property_name}: Expected value close to {expected_value} but got {actual_value}\")\n        else:\n            if actual_value != expected_value:\n                errors.append(f\"{property_name}: Expected {expected_value} but got {actual_value}\")\n    \n    if errors:\n        print(\"failed:\", \"; \".join(errors))\n    else:\n        print(\"ok\")"
    },
    {
        "properties_json_str": "{\n  \"JSON_File_Name\": \"test_wswq\",\n  \"properties\": {\n    \"distortion_mismatch_error\": {\n      \"description\": \"Checks if a ValueError is raised when there is a mismatch between the number of distortions and wswqs files.\",\n      \"format\": \"bool\",\n      \"value\": \"True\"\n    },\n    \"elph_me_defect_band_ediff\": {\n      \"description\": \"Verifies that the electron-phonon matrix element difference (ediff) is zero for the defect band.\",\n      \"format\": \"np.allclose\",\n      \"value\": \"0.0\"\n    },\n    \"elph_me_norm_nonzero\": {\n      \"description\": \"Ensures that the norm of the electron-phonon matrix element is greater than zero for a specific band index.\",\n      \"format\": \"bool\",\n      \"value\": \"True\"\n    }\n  }\n}",
        "question": "As a materials scientist, you are utilizing Pymatgen to write functions to calculate material properties. Here is what you need to do:\n- Calculate the following properties:\n    - `distortion_mismatch_error`: Checks if a ValueError is raised when there is a mismatch between the number of distortions and wswqs files. The format is a boolean.\n    - `elph_me_defect_band_ediff`: Verifies that the electron-phonon matrix element difference (ediff) is zero for the defect band. The format is a boolean indicating if the condition is met.\n    - `elph_me_norm_nonzero`: Ensures that the norm of the electron-phonon matrix element is greater than zero for a specific band index. The format is a boolean.\n\nIf you need to read files or generate data, please refer to the following instructions:\n- Read or Generate Data:\n    - Access the directory containing the WSWQ files at: `<path>tool_source_code/pymatgen-analysis-defects/tests/test_files/v_Ga/ccd_0_-1/wswqs</path>`.\n    - Use the Pymatgen function to read the HarmonicDefect data:\n      ```python\n      from pymatgen.analysis.defects.ccd import HarmonicDefect\n      from pymatgen.io.vasp.outputs import Procar, Vasprun\n      vaspruns = [Vasprun(f\"tool_source_code/pymatgen-analysis-defects/tests/test_files/v_Ga/ccd_0_-1/{i}/vasprun.xml\") for i in [0, 1, 2]]\n      procar = Procar(\"tool_source_code/pymatgen-analysis-defects/tests/test_files/v_Ga/ccd_0_-1/1/PROCAR\")\n      hd0 = HarmonicDefect.from_vaspruns(vaspruns, charge_state=0, procar=procar, store_bandstructure=True)\n      ```\n\nAll content is executed within the function, and the function does not require any input to output the result. The format of the function should follow these guidelines:\n- Write a Python function that:\n    - Reads the data from the provided file paths or generate data based on the description in the first section.\n    - Calculates all the properties mentioned above using Pymatgen.\n    - Returns a dictionary where the property names are keys, and the calculated results are the values.\n\n- Ensure your function includes:\n    - Necessary imports (e.g., `from pymatgen.analysis.defects.ccd import HarmonicDefect`).\n    - Proper file handling or data generation code.\n    - Output in the form of a dictionary as specified above.\n    - A complete docstring with clear input parameters, data types, and a description of the output.\n\n**Write the required Python function for this task**.",
        "new_unit_test": "def test_test_wswq(properties):\n    import numpy as np\n    expected_properties = {\n        \"distortion_mismatch_error\": {\n            \"format\": \"bool\",\n            \"value\": True\n        },\n        \"elph_me_defect_band_ediff\": {\n            \"format\": \"np.allclose\",\n            \"value\": 0.0\n        },\n        \"elph_me_norm_nonzero\": {\n            \"format\": \"bool\",\n            \"value\": True\n        }\n    }\n    \n    errors = []\n    \n    for property_name, expected_info in expected_properties.items():\n        expected_value = expected_info['value']\n        expected_format = expected_info['format']\n        \n        if property_name not in properties:\n            errors.append(f\"{property_name} not found in input properties\")\n            continue\n        \n        actual_value = properties[property_name]\n        \n        # Check type (skip type check for np.allclose cases as it's handled separately)\n        if expected_format != \"np.allclose\" and not isinstance(actual_value, eval(expected_format)):\n            errors.append(f\"{property_name} is not of type {expected_format}\")\n            continue\n        \n        # Check value or use np.allclose for approximate comparisons\n        if expected_format == \"np.allclose\":\n            if not np.allclose(actual_value, expected_value):\n                errors.append(f\"{property_name}: Expected value close to {expected_value} but got {actual_value}\")\n        else:\n            if actual_value != expected_value:\n                errors.append(f\"{property_name}: Expected {expected_value} but got {actual_value}\")\n    \n    if errors:\n        print(\"failed:\", \"; \".join(errors))\n    else:\n        print(\"ok\")"
    },
    {
        "properties_json_str": "{\n  \"JSON_File_Name\": \"test_wswq_slope\",\n  \"properties\": {\n    \"wswq_slope_positive_distortion\": {\n      \"description\": \"The slope of the WSWQ data when the distortion values are positive, indicating a change in the material's electronic structure.\",\n      \"format\": \"np.allclose (approximate comparison of arrays)\",\n      \"value\": \"array([[2., 2., 2., 2., 2.], [2., 2., 2., 2., 2.], [2., 2., 2., 2., 2.]])\"\n    },\n    \"wswq_slope_negative_distortion\": {\n      \"description\": \"The slope of the WSWQ data when the distortion values are negative, reflecting a different change in the material's electronic structure.\",\n      \"format\": \"np.allclose (approximate comparison of arrays)\",\n      \"value\": \"array([[1., 1., 1., 1., 1.], [1., 1., 1., 1., 1.], [1., 1., 1., 1., 1.]])\"\n    }\n  }\n}",
        "question": "As a materials scientist, you are utilizing Pymatgen to write functions to calculate material properties. Here is what you need to do:\n- Calculate the following properties:\n    - `wswq_slope_positive_distortion`: The slope of the WSWQ data when the distortion values are positive, indicating a change in the material's electronic structure. The format is a numpy array with approximate comparison using `np.allclose`.\n    - `wswq_slope_negative_distortion`: The slope of the WSWQ data when the distortion values are negative, reflecting a different change in the material's electronic structure. The format is a numpy array with approximate comparison using `np.allclose`.\n\nIf you need to read files or generate data, please refer to the following instructions:\n- Read or Generate Data:\n    - Generate fake WSWQ data using numpy arrays for testing purposes. You should use the following code snippet:\n    ```python\n    import numpy as np\n    from collections import namedtuple\n\n    mats = [np.ones((3, 5)), np.zeros((3, 5)), np.ones((3, 5))]\n    FakeWSWQ = namedtuple(\"FakeWSWQ\", [\"data\"])\n    fake_wswqs = [FakeWSWQ(data=m) for m in mats]\n    ```\n\nAll content is executed within the function, and the function does not require any input to output the result. The format of the function should follow these guidelines:\n- Write a Python function that:\n    - Generates the fake WSWQ data based on the description in the first section.\n    - Calculates all the properties mentioned above using Pymatgen.\n    - Returns a dictionary where the property names are keys, and the calculated results are the values.\n\n- Ensure your function includes:\n    - Necessary imports (e.g., `import numpy as np`).\n    - Proper data generation code.\n    - Output in the form of a dictionary as specified above.\n    - A complete docstring with clear input parameters, data types, and a description of the output.\n\n**Write the required Python function for this task**.",
        "new_unit_test": "def test_wswq_slope(properties):\n    import numpy as np\n    expected_properties = {\n        \"wswq_slope_positive_distortion\": {\n            \"format\": \"np.allclose\",\n            \"value\": np.array([[2., 2., 2., 2., 2.], [2., 2., 2., 2., 2.], [2., 2., 2., 2., 2.]])\n        },\n        \"wswq_slope_negative_distortion\": {\n            \"format\": \"np.allclose\",\n            \"value\": np.array([[1., 1., 1., 1., 1.], [1., 1., 1., 1., 1.], [1., 1., 1., 1., 1.]])\n        }\n    }\n    \n    errors = []\n    \n    for property_name, expected_info in expected_properties.items():\n        expected_value = expected_info['value']\n        expected_format = expected_info['format']\n        \n        if property_name not in properties:\n            errors.append(f\"{property_name} not found in input properties\")\n            continue\n        \n        actual_value = properties[property_name]\n        \n        # Check value using np.allclose for approximate comparisons\n        if expected_format == \"np.allclose\":\n            if not np.allclose(actual_value, expected_value):\n                errors.append(f\"{property_name}: Expected value close to {expected_value} but got {actual_value}\")\n    \n    if errors:\n        print(\"failed:\", \"; \".join(errors))\n    else:\n        print(\"ok\")"
    },
    {
        "properties_json_str": "{\n  \"JSON_File_Name\": \"test_SRHCapture\",\n  \"properties\": {\n    \"SRH_Coefficient\": {\n      \"description\": \"The Shockley-Read-Hall (SRH) coefficient, which quantifies the rate of non-radiative recombination in semiconductors, calculated for different temperatures.\",\n      \"format\": \"np.allclose (list of float values for approximate comparison)\",\n      \"value\": \"[1.89187260e-34, 6.21019152e-33, 3.51501688e-31]\"\n    },\n    \"RuntimeError_Check\": {\n      \"description\": \"Verification that a RuntimeError is raised when attempting to calculate the SRH coefficient with an invalid defect state configuration.\",\n      \"format\": \"bool\",\n      \"value\": \"True\"\n    }\n  }\n}",
        "question": "As a materials scientist, you are utilizing Pymatgen to write functions to calculate material properties. Here is what you need to do:\n- Calculate the following properties:\n    - `SRH_Coefficient`: The Shockley-Read-Hall (SRH) coefficient, which quantifies the rate of non-radiative recombination in semiconductors, calculated for different temperatures. The format should be a list of float values for approximate comparison.\n    - `RuntimeError_Check`: Verification that a RuntimeError is raised when attempting to calculate the SRH coefficient with an invalid defect state configuration. The format should be a boolean.\n\nIf you need to read files or generate data, please refer to the following instructions:\n- Read or Generate Data:\n    - Access the directory containing the WSWQ files at: `<path>tool_source_code/pymatgen-analysis-defects/tests/test_files/v_Ga/ccd_0_-1/wswqs</path>`.\n    - Use the Pymatgen function ```python\\nfrom pymatgen.analysis.defects.ccd import HarmonicDefect\\nfrom pymatgen.io.vasp.outputs import WSWQ\\nfrom pathlib import Path\\n\\n# Read WSWQ files\\nwswq_dir = Path(\"tool_source_code/pymatgen-analysis-defects/tests/test_files/v_Ga/ccd_0_-1/wswqs\")\\nwswq_files = sorted(wswq_dir.glob(\"WSWQ*\"), key=lambda x: int(x.name.split(\".\")[1]))\\nwswqs = [WSWQ.from_file(f) for f in wswq_files]\\n\\n# Create HarmonicDefect instance\\nhd0 = HarmonicDefect.from_vaspruns(vaspruns, charge_state=0, procar=procar, store_bandstructure=True)\\nhd0.read_wswqs(wswq_dir)\\n``` to read the WSWQ data and create a `HarmonicDefect` instance.\n\nAll content is executed within the function, and the function does not require any input to output the result. The format of the function should follow these guidelines:\n- Write a Python function that:\n    - Reads the data from the provided file paths or generates data based on the description in the first section.\n    - Calculates all the properties mentioned above using Pymatgen.\n    - Returns a dictionary where the property names are keys, and the calculated results are the values.\n\n- Ensure your function includes:\n    - Necessary imports (e.g., `from pymatgen.analysis.defects.ccd import get_SRH_coefficient`).\n    - Proper file handling or data generation code.\n    - Output in the form of a dictionary as specified above.\n    - A complete docstring with clear input parameters, data types, and a description of the output.\n\n**Write the required Python function for this task**.",
        "new_unit_test": "def test_SRHCapture(properties):\n    import numpy as np\n    expected_properties = {\n        \"SRH_Coefficient\": {\n            \"format\": \"np.allclose\",\n            \"value\": [1.89187260e-34, 6.21019152e-33, 3.51501688e-31]\n        },\n        \"RuntimeError_Check\": {\n            \"format\": \"bool\",\n            \"value\": True\n        }\n    }\n    \n    errors = []\n    \n    for property_name, expected_info in expected_properties.items():\n        expected_value = expected_info['value']\n        expected_format = expected_info['format']\n        \n        if property_name not in properties:\n            errors.append(f\"{property_name} not found in input properties\")\n            continue\n        \n        actual_value = properties[property_name]\n        \n        # Check type (skip type check for np.allclose cases as it's handled separately)\n        if expected_format != \"np.allclose\" and not isinstance(actual_value, eval(expected_format)):\n            errors.append(f\"{property_name} is not of type {expected_format}\")\n            continue\n        \n        # Check value or use np.allclose for approximate comparisons\n        if expected_format == \"np.allclose\":\n            if not np.allclose(actual_value, expected_value):\n                errors.append(f\"{property_name}: Expected value close to {expected_value} but got {actual_value}\")\n        else:\n            if actual_value != expected_value:\n                errors.append(f\"{property_name}: Expected {expected_value} but got {actual_value}\")\n    \n    if errors:\n        print(\"failed:\", \"; \".join(errors))\n    else:\n        print(\"ok\")"
    },
    {
        "properties_json_str": "{\n  \"JSON_File_Name\": \"test_dielectric_func\",\n  \"properties\": {\n    \"inter_vbm_integral\": {\n      \"description\": \"Integral of the imaginary part of the dielectric function at the valence band maximum (VBM) over a specified energy range.\",\n      \"format\": \"np.allclose (approximate float comparison)\",\n      \"value\": \"6.31\"\n    },\n    \"inter_cbm_integral\": {\n      \"description\": \"Integral of the imaginary part of the dielectric function at the conduction band minimum (CBM) over a specified energy range.\",\n      \"format\": \"np.allclose (approximate float comparison)\",\n      \"value\": \"0.27\"\n    },\n    \"optical_transitions_dataframe_type\": {\n      \"description\": \"Verification that the result of plotting optical transitions is a pandas DataFrame.\",\n      \"format\": \"bool\",\n      \"value\": \"True\"\n    },\n    \"optical_transitions_dataframe_length\": {\n      \"description\": \"Number of entries in the DataFrame resulting from plotting optical transitions.\",\n      \"format\": \"int\",\n      \"value\": \"11\"\n    },\n    \"optical_transitions_user_defect_band_ib\": {\n      \"description\": \"Index of the initial band (ib) in the user-defined defect band structure for optical transitions.\",\n      \"format\": \"int\",\n      \"value\": \"100\"\n    },\n    \"optical_transitions_user_defect_band_jb\": {\n      \"description\": \"Index of the final band (jb) in the user-defined defect band structure for optical transitions.\",\n      \"format\": \"int\",\n      \"value\": \"100\"\n    }\n  }\n}",
        "question": "As a materials scientist, you are utilizing Pymatgen to write functions to calculate material properties. Here is what you need to do:\n- Calculate the following properties:\n    - `inter_vbm_integral`: Integral of the imaginary part of the dielectric function at the valence band maximum (VBM) over a specified energy range. The result should be approximately 6.31 (float).\n    - `inter_cbm_integral`: Integral of the imaginary part of the dielectric function at the conduction band minimum (CBM) over a specified energy range. The result should be approximately 0.27 (float).\n    - `optical_transitions_dataframe_type`: Verification that the result of plotting optical transitions is a pandas DataFrame (bool).\n    - `optical_transitions_dataframe_length`: Number of entries in the DataFrame resulting from plotting optical transitions (int).\n    - `optical_transitions_user_defect_band_ib`: Index of the initial band (ib) in the user-defined defect band structure for optical transitions (int).\n    - `optical_transitions_user_defect_band_jb`: Index of the final band (jb) in the user-defined defect band structure for optical transitions (int).\n\nIf you need to read files or generate data, please refer to the following instructions:\n- Read or Generate Data:\n    - Access the directory containing the necessary files at: `<path>tool_source_code/pymatgen-analysis-defects/tests/test_files/v_Ga/ccd_0_-1/optics</path>`.\n    - Use the Pymatgen function ```python\\nfrom pymatgen.analysis.defects.ccd import HarmonicDefect\\nHarmonicDefect.from_directories(directories=[dir0_opt], store_bandstructure=True)\\n``` to create a `HarmonicDefect` object.\n    - Use the Pymatgen function ```python\\nfrom pymatgen.io.vasp.outputs import Waveder\\nWaveder.from_binary(dir0_opt / \"WAVEDER\")\\n``` to read the WAVEDER file and assign it to the `waveder` attribute of the `HarmonicDefect` object.\n    - Use the method `get_dielectric_function(idir=0, jdir=0)` on the `HarmonicDefect` object to obtain the energy, eps_vbm, and eps_cbm arrays.\n    - Use the function `plot_optical_transitions(hd0, kpt_index=0, band_window=5)` to generate the optical transitions DataFrame.\n\nAll content is executed within the function, and the function does not require any input to output the result. The format of the function should follow these guidelines:\n- Write a Python function that:\n    - Reads the data from the provided file paths or generate data based on the description in the first section.\n    - Calculates all the properties mentioned above using Pymatgen.\n    - Returns a dictionary where the property names are keys, and the calculated results are the values.\n\n- Ensure your function includes:\n    - Necessary imports (e.g., `from pymatgen.analysis.defects.ccd import HarmonicDefect`).\n    - Proper file handling or data generation code.\n    - Output in the form of a dictionary as specified above.\n    - A complete docstring with clear input parameters, data types, and a description of the output.\n\n**Write the required Python function for this task**.",
        "new_unit_test": "def test_dielectric_func(properties):\n    import numpy as np\n    expected_properties = {\n        \"inter_vbm_integral\": {\n            \"format\": \"np.allclose\",\n            \"value\": 6.31\n        },\n        \"inter_cbm_integral\": {\n            \"format\": \"np.allclose\",\n            \"value\": 0.27\n        },\n        \"optical_transitions_dataframe_type\": {\n            \"format\": \"bool\",\n            \"value\": True\n        },\n        \"optical_transitions_dataframe_length\": {\n            \"format\": \"int\",\n            \"value\": 11\n        },\n        \"optical_transitions_user_defect_band_ib\": {\n            \"format\": \"int\",\n            \"value\": 100\n        },\n        \"optical_transitions_user_defect_band_jb\": {\n            \"format\": \"int\",\n            \"value\": 100\n        }\n    }\n    \n    errors = []\n    \n    for property_name, expected_info in expected_properties.items():\n        expected_value = expected_info['value']\n        expected_format = expected_info['format']\n        \n        if property_name not in properties:\n            errors.append(f\"{property_name} not found in input properties\")\n            continue\n        \n        actual_value = properties[property_name]\n        \n        # Check type (skip type check for np.allclose cases as it's handled separately)\n        if expected_format != \"np.allclose\" and not isinstance(actual_value, eval(expected_format)):\n            errors.append(f\"{property_name} is not of type {expected_format}\")\n            continue\n        \n        # Check value or use np.allclose for approximate comparisons\n        if expected_format == \"np.allclose\":\n            if not np.allclose(actual_value, expected_value):\n                errors.append(f\"{property_name}: Expected value close to {expected_value} but got {actual_value}\")\n        else:\n            if actual_value != expected_value:\n                errors.append(f\"{property_name}: Expected {expected_value} but got {actual_value}\")\n    \n    if errors:\n        print(\"failed:\", \"; \".join(errors))\n    else:\n        print(\"ok\")"
    },
    {
        "properties_json_str": null,
        "question": "As a materials scientist, you are utilizing Pymatgen to write functions to calculate material properties. Here is what you need to do:\n- Calculate the following properties:\n    - `inter_vbm_integral`: Integral of the imaginary part of the dielectric function at the valence band maximum (VBM) over a specified energy range. The result should be approximately 6.31 (float).\n    - `inter_cbm_integral`: Integral of the imaginary part of the dielectric function at the conduction band minimum (CBM) over a specified energy range. The result should be approximately 0.27 (float).\n    - `optical_transitions_dataframe_type`: Verification that the result of plotting optical transitions is a pandas DataFrame (bool).\n    - `optical_transitions_dataframe_length`: Number of entries in the DataFrame resulting from plotting optical transitions (int).\n    - `optical_transitions_user_defect_band_ib`: Index of the initial band (ib) in the user-defined defect band structure for optical transitions (int).\n    - `optical_transitions_user_defect_band_jb`: Index of the final band (jb) in the user-defined defect band structure for optical transitions (int).\n\nIf you need to read files or generate data, please refer to the following instructions:\n- Read or Generate Data:\n    - Access the directory containing the necessary files at: `<path>tool_source_code/pymatgen-analysis-defects/tests/test_files/v_Ga/ccd_0_-1/optics</path>`.\n    - Use the Pymatgen function ```python\\nfrom pymatgen.analysis.defects.ccd import HarmonicDefect\\nHarmonicDefect.from_directories(directories=[dir0_opt], store_bandstructure=True)\\n``` to create a `HarmonicDefect` object.\n    - Use the Pymatgen function ```python\\nfrom pymatgen.io.vasp.outputs import Waveder\\nWaveder.from_binary(dir0_opt / \"WAVEDER\")\\n``` to read the WAVEDER file and assign it to the `waveder` attribute of the `HarmonicDefect` object.\n    - Use the method `get_dielectric_function(idir=0, jdir=0)` on the `HarmonicDefect` object to obtain the energy, eps_vbm, and eps_cbm arrays.\n    - Use the function `plot_optical_transitions(hd0, kpt_index=0, band_window=5)` to generate the optical transitions DataFrame.\n\nAll content is executed within the function, and the function does not require any input to output the result. The format of the function should follow these guidelines:\n- Write a Python function that:\n    - Reads the data from the provided file paths or generate data based on the description in the first section.\n    - Calculates all the properties mentioned above using Pymatgen.\n    - Returns a dictionary where the property names are keys, and the calculated results are the values.\n\n- Ensure your function includes:\n    - Necessary imports (e.g., `from pymatgen.analysis.defects.ccd import HarmonicDefect`).\n    - Proper file handling or data generation code.\n    - Output in the form of a dictionary as specified above.\n    - A complete docstring with clear input parameters, data types, and a description of the output.\n\n**Write the required Python function for this task**.",
        "new_unit_test": "def test_dielectric_func(properties):\n    import numpy as np\n    expected_properties = {\n        \"inter_vbm_integral\": {\n            \"format\": \"np.allclose\",\n            \"value\": 6.31\n        },\n        \"inter_cbm_integral\": {\n            \"format\": \"np.allclose\",\n            \"value\": 0.27\n        },\n        \"optical_transitions_dataframe_type\": {\n            \"format\": \"bool\",\n            \"value\": True\n        },\n        \"optical_transitions_dataframe_length\": {\n            \"format\": \"int\",\n            \"value\": 11\n        },\n        \"optical_transitions_user_defect_band_ib\": {\n            \"format\": \"int\",\n            \"value\": 100\n        },\n        \"optical_transitions_user_defect_band_jb\": {\n            \"format\": \"int\",\n            \"value\": 100\n        }\n    }\n    \n    errors = []\n    \n    for property_name, expected_info in expected_properties.items():\n        expected_value = expected_info['value']\n        expected_format = expected_info['format']\n        \n        if property_name not in properties:\n            errors.append(f\"{property_name} not found in input properties\")\n            continue\n        \n        actual_value = properties[property_name]\n        \n        # Check type (skip type check for np.allclose cases as it's handled separately)\n        if expected_format != \"np.allclose\" and not isinstance(actual_value, eval(expected_format)):\n            errors.append(f\"{property_name} is not of type {expected_format}\")\n            continue\n        \n        # Check value or use np.allclose for approximate comparisons\n        if expected_format == \"np.allclose\":\n            if not np.allclose(actual_value, expected_value):\n                errors.append(f\"{property_name}: Expected value close to {expected_value} but got {actual_value}\")\n        else:\n            if actual_value != expected_value:\n                errors.append(f\"{property_name}: Expected {expected_value} but got {actual_value}\")\n    \n    if errors:\n        print(\"failed:\", \"; \".join(errors))\n    else:\n        print(\"ok\")"
    },
    {
        "properties_json_str": "{\n  \"JSON_File_Name\": \"test_supercells\",\n  \"properties\": {\n    \"supercell_matrix_shape\": {\n      \"description\": \"The shape of the supercell transformation matrix, which should be a 3x3 matrix indicating the transformation from the unit cell to the supercell.\",\n      \"format\": \"tuple\",\n      \"value\": \"(3, 3)\"\n    },\n    \"matched_supercell_matrix_shape\": {\n      \"description\": \"The shape of the matched supercell transformation matrix, which should also be a 3x3 matrix, ensuring consistency in the transformation.\",\n      \"format\": \"tuple\",\n      \"value\": \"(3, 3)\"\n    },\n    \"supercell_lattice_parameters_consistency\": {\n      \"description\": \"The consistency of lattice parameters between two supercells generated from different transformation matrices, ensuring they are equivalent.\",\n      \"format\": \"np.allclose\",\n      \"value\": \"True\"\n    }\n  }\n}",
        "question": "As a materials scientist, you are utilizing Pymatgen to write functions to calculate material properties. Here is what you need to do:\n- Calculate the following properties:\n    - `supercell_matrix_shape`: The shape of the supercell transformation matrix, which should be a 3x3 matrix indicating the transformation from the unit cell to the supercell. The format is a tuple.\n    - `matched_supercell_matrix_shape`: The shape of the matched supercell transformation matrix, which should also be a 3x3 matrix, ensuring consistency in the transformation. The format is a tuple.\n    - `supercell_lattice_parameters_consistency`: The consistency of lattice parameters between two supercells generated from different transformation matrices, ensuring they are equivalent. The format is a boolean indicating if the parameters are consistent.\n\nIf you need to read files or generate data, please refer to the following instructions:\n- Read or Generate Data:\n    - Access the structure file at: `<path>tool_source_code/pymatgen-analysis-defects/tests/test_files/GaN.vasp</path>`.\n    - Use the Pymatgen function:\n    ```python\n    from pymatgen.core import Structure\n    gan_struct = Structure.from_file(file_path / \"GaN.vasp\")\n    ```\n    - Use the Pymatgen functions:\n    ```python\n    from pymatgen.analysis.defects.supercells import get_sc_fromstruct, get_matched_structure_mapping\n    sc_mat = get_sc_fromstruct(gan_struct)\n    sc = gan_struct * sc_mat\n    sc_mat2, _ = get_matched_structure_mapping(gan_struct, sc)\n    sc2 = gan_struct * sc_mat2\n    ```\n\nAll content is executed within the function, and the function does not require any input to output the result. The format of the function should follow these guidelines:\n- Write a Python function that:\n    - Reads the data from the provided file paths or generate data based on the description in the first section.\n    - Calculates all the properties mentioned above using Pymatgen.\n    - Returns a dictionary where the property names are keys, and the calculated results are the values.\n\n- Ensure your function includes:\n    - Necessary imports (e.g., `from pymatgen.core import Structure`).\n    - Proper file handling or data generation code.\n    - Output in the form of a dictionary as specified above.\n    - A complete docstring with clear input parameters, data types, and a description of the output.\n\n**Write the required Python function for this task**.",
        "new_unit_test": "def test_supercells(properties):\n    import numpy as np\n    expected_properties = {\n        \"supercell_matrix_shape\": {\n            \"format\": \"tuple\",\n            \"value\": (3, 3)\n        },\n        \"matched_supercell_matrix_shape\": {\n            \"format\": \"tuple\",\n            \"value\": (3, 3)\n        },\n        \"supercell_lattice_parameters_consistency\": {\n            \"format\": \"np.allclose\",\n            \"value\": True\n        }\n    }\n    \n    errors = []\n    \n    for property_name, expected_info in expected_properties.items():\n        expected_value = expected_info['value']\n        expected_format = expected_info['format']\n        \n        if property_name not in properties:\n            errors.append(f\"{property_name} not found in input properties\")\n            continue\n        \n        actual_value = properties[property_name]\n        \n        # Check type (skip type check for np.allclose cases as it's handled separately)\n        if expected_format != \"np.allclose\" and not isinstance(actual_value, eval(expected_format)):\n            errors.append(f\"{property_name} is not of type {expected_format}\")\n            continue\n        \n        # Check value or use np.allclose for approximate comparisons\n        if expected_format == \"np.allclose\":\n            if not np.allclose(actual_value, expected_value):\n                errors.append(f\"{property_name}: Expected value close to {expected_value} but got {actual_value}\")\n        else:\n            if actual_value != expected_value:\n                errors.append(f\"{property_name}: Expected {expected_value} but got {actual_value}\")\n    \n    if errors:\n        print(\"failed:\", \"; \".join(errors))\n    else:\n        print(\"ok\")"
    },
    {
        "properties_json_str": "{\n  \"JSON_File_Name\": \"test_ase_supercells\",\n  \"properties\": {\n    \"supercell_size_constraint\": {\n      \"description\": \"Ensures that the generated supercell has a number of sites within the specified range.\",\n      \"format\": \"bool\",\n      \"value\": \"True\"\n    },\n    \"supercell_generation_failure\": {\n      \"description\": \"Tests that a RuntimeError is raised when the minimum length constraint cannot be satisfied for supercell generation.\",\n      \"format\": \"bool\",\n      \"value\": \"True\"\n    }\n  }\n}",
        "question": "As a materials scientist, you are utilizing Pymatgen to write functions to calculate material properties. Here is what you need to do:\n- Calculate the following properties:\n    - `supercell_size_constraint`: Ensures that the generated supercell has a number of sites within the specified range. The format is a boolean.\n    - `supercell_generation_failure`: Tests that a RuntimeError is raised when the minimum length constraint cannot be satisfied for supercell generation. The format is a boolean.\n\nIf you need to read files or generate data, please refer to the following instructions:\n- Read or Generate Data:\n    - Access the structure file at: `<path>tool_source_code/pymatgen-analysis-defects/tests/test_files/GaN.vasp</path>`.\n    - Use the Pymatgen function:\n    ```python\n    from pymatgen.core import Structure\n    gan_struct = Structure.from_file(file_path / \"GaN.vasp\")\n    ```\n    to read the structure data.\n    - Use the Pymatgen function:\n    ```python\n    from pymatgen.analysis.defects.supercells import _ase_cubic\n    sc_mat = _ase_cubic(gan_struct, min_atoms=4, max_atoms=8, min_length=1.0)\n    sc = gan_struct * sc_mat\n    ```\n    to generate the supercell.\n\nAll content is executed within the function, and the function does not require any input to output the result. The format of the function should follow these guidelines:\n- Write a Python function that:\n    - Reads the data from the provided file paths or generate data based on the description in the first section.\n    - Calculates all the properties mentioned above using Pymatgen.\n    - Returns a dictionary where the property names are keys, and the calculated results are the values.\n\n- Ensure your function includes:\n    - Necessary imports (e.g., `from pymatgen.core import Structure`).\n    - Proper file handling or data generation code.\n    - Output in the form of a dictionary as specified above.\n    - A complete docstring with clear input parameters, data types, and a description of the output.\n\n**Write the required Python function for this task**.",
        "new_unit_test": "def test_ase_supercells(properties):\n    import numpy as np\n    expected_properties = {\n        \"supercell_size_constraint\": {\n            \"format\": \"bool\",\n            \"value\": True\n        },\n        \"supercell_generation_failure\": {\n            \"format\": \"bool\",\n            \"value\": True\n        }\n    }\n    \n    errors = []\n    \n    for property_name, expected_info in expected_properties.items():\n        expected_value = expected_info['value']\n        expected_format = expected_info['format']\n        \n        if property_name not in properties:\n            errors.append(f\"{property_name} not found in input properties\")\n            continue\n        \n        actual_value = properties[property_name]\n        \n        # Check type (skip type check for np.allclose cases as it's handled separately)\n        if expected_format != \"np.allclose\" and not isinstance(actual_value, eval(expected_format)):\n            errors.append(f\"{property_name} is not of type {expected_format}\")\n            continue\n        \n        # Check value or use np.allclose for approximate comparisons\n        if expected_format == \"np.allclose\":\n            if not np.allclose(actual_value, expected_value):\n                errors.append(f\"{property_name}: Expected value close to {expected_value} but got {actual_value}\")\n        else:\n            if actual_value != expected_value:\n                errors.append(f\"{property_name}: Expected {expected_value} but got {actual_value}\")\n    \n    if errors:\n        print(\"failed:\", \"; \".join(errors))\n    else:\n        print(\"ok\")"
    },
    {
        "properties_json_str": "{\n  \"JSON_File_Name\": \"Si-O_structs.json\",\n  \"properties\": {\n    \"supercell_structure_matching\": {\n      \"description\": \"Checks if the generated supercell structure closely matches a reference supercell matrix by comparing the minimum distance of sorted results.\",\n      \"format\": \"bool (using np.allclose for approximate comparison)\",\n      \"value\": \"True\"\n    },\n    \"closest_supercell_matrix\": {\n      \"description\": \"Verifies that the closest supercell matrix obtained from the unit cell and vacancy supercell structures matches the reference supercell matrix.\",\n      \"format\": \"np.allclose (for approximate comparison of matrices)\",\n      \"value\": \"[[2, 1, 2], [2, 0, 3], [2, 1, 1]]\"\n    }\n  }\n}",
        "question": "As a materials scientist, you are utilizing Pymatgen to write functions to calculate material properties. Here is what you need to do:\n- Calculate the following properties:\n    - `supercell_structure_matching`: Checks if the generated supercell structure closely matches a reference supercell matrix by comparing the minimum distance of sorted results. The result should be a boolean value using `np.allclose` for approximate comparison.\n    - `closest_supercell_matrix`: Verifies that the closest supercell matrix obtained from the unit cell and vacancy supercell structures matches the reference supercell matrix. The result should be a matrix in the format `np.allclose` for approximate comparison of matrices.\n\nIf you need to read files or generate data, please refer to the following instructions:\n- Read or Generate Data:\n    - Access the structure file at: `<path>tool_source_code/pymatgen-analysis-defects/tests/test_files/Si-O_structs.json</path>`.\n    - Use the Pymatgen function ```python\\nfrom monty.serialization import loadfn\\nsi_o_structs = loadfn(file_path / \"Si-O_structs.json\")\\n``` to read the structure data.\n    - Generate vacancy structures using Pymatgen's `VacancyGenerator` and obtain supercell structures using the function `get_supercell_structure`.\n    - Use the function `get_closest_sc_mat` to find the closest supercell matrix.\n\nAll content is executed within the function, and the function does not require any input to output the result. The format of the function should follow these guidelines:\n- Write a Python function that:\n    - Reads the data from the provided file paths or generates data based on the description in the first section.\n    - Calculates all the properties mentioned above using Pymatgen.\n    - Returns a dictionary where the property names are keys, and the calculated results are the values.\n\n- Ensure your function includes:\n    - Necessary imports (e.g., `from pymatgen.analysis.defects.generators import VacancyGenerator`).\n    - Proper file handling or data generation code.\n    - Output in the form of a dictionary as specified above.\n    - A complete docstring with clear input parameters, data types, and a description of the output.\n\n**Write the required Python function for this task**.",
        "new_unit_test": "def test_Si_O_structs_json(properties):\n    import numpy as np\n    expected_properties = {\n        \"supercell_structure_matching\": {\n            \"format\": \"bool\",\n            \"value\": True\n        },\n        \"closest_supercell_matrix\": {\n            \"format\": \"np.allclose\",\n            \"value\": np.array([[2, 1, 2], [2, 0, 3], [2, 1, 1]])\n        }\n    }\n    \n    errors = []\n    \n    for property_name, expected_info in expected_properties.items():\n        expected_value = expected_info['value']\n        expected_format = expected_info['format']\n        \n        if property_name not in properties:\n            errors.append(f\"{property_name} not found in input properties\")\n            continue\n        \n        actual_value = properties[property_name]\n        \n        # Check type (skip type check for np.allclose cases as it's handled separately)\n        if expected_format != \"np.allclose\" and not isinstance(actual_value, eval(expected_format)):\n            errors.append(f\"{property_name} is not of type {expected_format}\")\n            continue\n        \n        # Check value or use np.allclose for approximate comparisons\n        if expected_format == \"np.allclose\":\n            if not np.allclose(actual_value, expected_value):\n                errors.append(f\"{property_name}: Expected value close to {expected_value} but got {actual_value}\")\n        else:\n            if actual_value != expected_value:\n                errors.append(f\"{property_name}: Expected {expected_value} but got {actual_value}\")\n    \n    if errors:\n        print(\"failed:\", \"; \".join(errors))\n    else:\n        print(\"ok\")"
    },
    {
        "properties_json_str": "{\n  \"JSON_File_Name\": \"test_freysoldt\",\n  \"properties\": {\n    \"freysoldt_correction_energy\": {\n      \"description\": \"The correction energy calculated using the Freysoldt method, which accounts for electrostatic interactions in charged defects within a periodic lattice.\",\n      \"format\": \"pytest.approx (float)\",\n      \"value\": \"0\"\n    }\n  }\n}",
        "question": "As a materials scientist, you are utilizing Pymatgen to write functions to calculate material properties. Here is what you need to do:\n- Calculate the following properties:\n    - `freysoldt_correction_energy`: The correction energy calculated using the Freysoldt method, which accounts for electrostatic interactions in charged defects within a periodic lattice. The format should be a float, approximately equal to 0.\n\nIf you need to read files or generate data, please refer to the following instructions:\n- Read or Generate Data:\n    - Access the data for Mg_Ga at: `<path>tool_source_code/pymatgen-analysis-defects/tests/test_files/Mg_Ga</path>`.\n    - Use the Pymatgen function to read the data:\n    ```python\n    from collections import defaultdict\n    from pymatgen.io.vasp.outputs import Locpot, Vasprun\n    from pathlib import Path\n\n    def get_data_Mg_Ga():\n        test_dir = Path.cwd() / 'tool_source_code/pymatgen-analysis-defects/tests/test_files/'\n        root_dir = test_dir / \"Mg_Ga\"\n        data = defaultdict(dict)\n        for fold in root_dir.glob(\"./*\"):\n            if not fold.is_dir():\n                continue\n            data[fold.name] = {\n                \"vasprun\": Vasprun(fold / \"vasprun.xml.gz\"),\n                \"locpot\": Locpot.from_file(fold / \"LOCPOT.gz\"),\n            }\n        return data\n    ```\n\nAll content is executed within the function, and the function does not require any input to output the result. The format of the function should follow these guidelines:\n- Write a Python function that:\n    - Reads the data from the provided file paths or generates data based on the description in the first section.\n    - Calculates all the properties mentioned above using Pymatgen.\n    - Returns a dictionary where the property names are keys, and the calculated results are the values.\n\n- Ensure your function includes:\n    - Necessary imports (e.g., `from pymatgen.analysis.defects.corrections.freysoldt import get_freysoldt_correction`).\n    - Proper file handling or data generation code.\n    - Output in the form of a dictionary as specified above.\n    - A complete docstring with clear input parameters, data types, and a description of the output.\n\n**Write the required Python function for this task**.",
        "new_unit_test": "def test_freysoldt(properties):\n    import numpy as np\n    expected_properties = {\n        \"freysoldt_correction_energy\": {\n            \"format\": \"np.allclose\",\n            \"value\": 0.0\n        }\n    }\n    \n    errors = []\n    \n    for property_name, expected_info in expected_properties.items():\n        expected_value = expected_info['value']\n        expected_format = expected_info['format']\n        \n        if property_name not in properties:\n            errors.append(f\"{property_name} not found in input properties\")\n            continue\n        \n        actual_value = properties[property_name]\n        \n        # Check value or use np.allclose for approximate comparisons\n        if expected_format == \"np.allclose\":\n            if not np.allclose(actual_value, expected_value):\n                errors.append(f\"{property_name}: Expected value close to {expected_value} but got {actual_value}\")\n        else:\n            if actual_value != expected_value:\n                errors.append(f\"{property_name}: Expected {expected_value} but got {actual_value}\")\n    \n    if errors:\n        print(\"failed:\", \"; \".join(errors))\n    else:\n        print(\"ok\")"
    },
    {
        "properties_json_str": "{\n  \"JSON_File_Name\": \"test_freysoldt_sxdefect_compare\",\n  \"properties\": {\n    \"freysoldt_correction_energy\": {\n      \"description\": \"The Freysoldt correction energy is a calculated value used to correct the electrostatic potential alignment in defect calculations, compared against reference values from the sxdefectalign tool.\",\n      \"format\": \"np.allclose (approximate comparison with pytest.approx)\",\n      \"value\": \"0.366577 for charge state -1\"\n    }\n  }\n}",
        "question": "As a materials scientist, you are utilizing Pymatgen to write functions to calculate material properties. Here is what you need to do:\n- Calculate the following properties:\n    - `freysoldt_correction_energy`: The Freysoldt correction energy is a calculated value used to correct the electrostatic potential alignment in defect calculations, compared against reference values from the sxdefectalign tool. The value for charge state -1 should be approximately 0.366577.\n\nIf you need to read files or generate data, please refer to the following instructions:\n- Read or Generate Data:\n    - Access the bulk electrostatic potential file at: `<path>tool_source_code/pymatgen-analysis-defects/tests/test_files/v_N_GaN/bulk/LOCPOT.gz</path>`.\n    - Access the defect electrostatic potential files for charge states -1, 0, 1, and 2 at:\n        - `<path>tool_source_code/pymatgen-analysis-defects/tests/test_files/v_N_GaN/q=-1/LOCPOT.gz</path>`\n        - `<path>tool_source_code/pymatgen-analysis-defects/tests/test_files/v_N_GaN/q=0/LOCPOT.gz</path>`\n        - `<path>tool_source_code/pymatgen-analysis-defects/tests/test_files/v_N_GaN/q=1/LOCPOT.gz</path>`\n        - `<path>tool_source_code/pymatgen-analysis-defects/tests/test_files/v_N_GaN/q=2/LOCPOT.gz</path>`\n    - Use the Pymatgen function ```python\\nfrom pymatgen.io.vasp.outputs import Locpot\\nLocpot.from_file(file_path)\\n``` to read the electrostatic potential data.\n\nAll content is executed within the function, and the function does not require any input to output the result. The format of the function should follow these guidelines:\n- Write a Python function that:\n    - Reads the data from the provided file paths.\n    - Calculates the Freysoldt correction energy for charge state -1 using Pymatgen.\n    - Returns a dictionary where the property name is the key, and the calculated result is the value.\n\n- Ensure your function includes:\n    - Necessary imports (e.g., `from pymatgen.io.vasp.outputs import Locpot`).\n    - Proper file handling code.\n    - Output in the form of a dictionary as specified above.\n    - A complete docstring with a description of the output.\n\n**Write the required Python function for this task**.",
        "new_unit_test": "def test_freysoldt_sxdefect_compare(properties):\n    import numpy as np\n    expected_properties = {\n        \"freysoldt_correction_energy\": {\n            \"format\": \"np.allclose\",\n            \"value\": 0.366577  # for charge state -1\n        }\n    }\n    \n    errors = []\n    \n    for property_name, expected_info in expected_properties.items():\n        expected_value = expected_info['value']\n        expected_format = expected_info['format']\n        \n        if property_name not in properties:\n            errors.append(f\"{property_name} not found in input properties\")\n            continue\n        \n        actual_value = properties[property_name]\n        \n        # Check value using np.allclose for approximate comparisons\n        if expected_format == \"np.allclose\":\n            if not np.allclose(actual_value, expected_value):\n                errors.append(f\"{property_name}: Expected value close to {expected_value} but got {actual_value}\")\n        else:\n            if actual_value != expected_value:\n                errors.append(f\"{property_name}: Expected {expected_value} but got {actual_value}\")\n    \n    if errors:\n        print(\"failed:\", \"; \".join(errors))\n    else:\n        print(\"ok\")"
    },
    {
        "properties_json_str": "{\n  \"JSON_File_Name\": \"test_kumagai\",\n  \"properties\": {\n    \"correction_energy_neutral\": {\n      \"description\": \"The correction energy for a neutral defect state, expected to be approximately zero.\",\n      \"format\": \"float (using pytest.approx for approximate comparison)\",\n      \"value\": \"0\"\n    },\n    \"correction_energy_charged\": {\n      \"description\": \"The correction energy for a charged defect state, expected to be greater than zero.\",\n      \"format\": \"float\",\n      \"value\": \"> 0\"\n    }\n  }\n}",
        "question": "As a materials scientist, you are utilizing Pymatgen to write functions to calculate material properties. Here is what you need to do:\n- Calculate the following properties:\n    - `correction_energy_neutral`: The correction energy for a neutral defect state, expected to be approximately zero. Format: float (using pytest.approx for approximate comparison).\n    - `correction_energy_charged`: The correction energy for a charged defect state, expected to be greater than zero. Format: float.\n\nIf you need to read files or generate data, please refer to the following instructions:\n- Read or Generate Data:\n    - Access the structure files at: \n        - `<path>tool_source_code/pymatgen-analysis-defects/tests/test_files/Mg_Ga/bulk_sc</path>`.\n        - `<path>tool_source_code/pymatgen-analysis-defects/tests/test_files/Mg_Ga/q=0</path>`.\n        - `<path>tool_source_code/pymatgen-analysis-defects/tests/test_files/Mg_Ga/q=1</path>`.\n    - Use the Pymatgen function ```python\\nfrom pymatgen.analysis.defects.corrections.kumagai import get_structure_with_pot\\nget_structure_with_pot(file_path)\\n``` to read the structure data.\n\nAll content is executed within the function, and the function does not require any input to output the result. The format of the function should follow these guidelines:\n- Write a Python function that:\n    - Reads the data from the provided file paths.\n    - Calculates all the properties mentioned above using Pymatgen.\n    - Returns a dictionary where the property names are keys, and the calculated results are the values.\n\n- Ensure your function includes:\n    - Necessary imports (e.g., `from pymatgen.analysis.defects.corrections.kumagai import get_efnv_correction`).\n    - Proper file handling or data generation code.\n    - Output in the form of a dictionary as specified above.\n    - A complete docstring with clear input parameters, data types, and a description of the output.\n\n**Write the required Python function for this task**.",
        "new_unit_test": "def test_test_kumagai(properties):\n    import numpy as np\n    expected_properties = {\n        \"correction_energy_neutral\": {\n            \"format\": \"np.allclose\",\n            \"value\": 0.0\n        },\n        \"correction_energy_charged\": {\n            \"format\": \"float\",\n            \"value\": \"> 0\"\n        }\n    }\n    \n    errors = []\n    \n    for property_name, expected_info in expected_properties.items():\n        expected_value = expected_info['value']\n        expected_format = expected_info['format']\n        \n        if property_name not in properties:\n            errors.append(f\"{property_name} not found in input properties\")\n            continue\n        \n        actual_value = properties[property_name]\n        \n        # Check type (skip type check for np.allclose cases as it's handled separately)\n        if expected_format != \"np.allclose\" and not isinstance(actual_value, eval(expected_format)):\n            errors.append(f\"{property_name} is not of type {expected_format}\")\n            continue\n        \n        # Check value or use np.allclose for approximate comparisons\n        if expected_format == \"np.allclose\":\n            if not np.allclose(actual_value, expected_value):\n                errors.append(f\"{property_name}: Expected value close to {expected_value} but got {actual_value}\")\n        else:\n            if expected_value == \"> 0\":\n                if not actual_value > 0:\n                    errors.append(f\"{property_name}: Expected value greater than 0 but got {actual_value}\")\n            else:\n                if actual_value != expected_value:\n                    errors.append(f\"{property_name}: Expected {expected_value} but got {actual_value}\")\n    \n    if errors:\n        print(\"failed:\", \"; \".join(errors))\n    else:\n        print(\"ok\")"
    },
    {
        "properties_json_str": "{\n  \"JSON_File_Name\": \"test_kumagai_missing\",\n  \"properties\": {\n    \"pydefect_import_check\": {\n      \"description\": \"Checks if the pydefect module is available for import, which is necessary for certain defect correction calculations.\",\n      \"format\": \"bool\",\n      \"value\": \"False\"\n    }\n  }\n}",
        "question": "As a materials scientist, you are utilizing Pymatgen to write functions to calculate material properties. Here is what you need to do:\n- Calculate the following properties:\n    - `pydefect_import_check`: Checks if the pydefect module is available for import, which is necessary for certain defect correction calculations. The format is a boolean.\n\nIf you need to read files or generate data, please refer to the following instructions:\n- Read or Generate Data:\n    - There is no need to read any files for this task. The property is determined by checking the availability of the `pydefect` module in the Pymatgen library.\n\nAll content is executed within the function, and the function does not require any input to output the result. The format of the function should follow these guidelines:\n- Write a Python function that:\n    - Checks the availability of the `pydefect` module in Pymatgen.\n    - Returns a dictionary where the property name `pydefect_import_check` is the key, and the boolean result of the check is the value.\n\n- Ensure your function includes:\n    - Necessary imports (e.g., `import importlib`).\n    - Proper module checking code.\n    - Output in the form of a dictionary as specified above.\n    - A complete docstring with clear input parameters, data types, and a description of the output.\n\n**Write the required Python function for this task**.",
        "new_unit_test": "def test_kumagai_missing(properties):\n    import numpy as np\n    expected_properties = {\n        \"pydefect_import_check\": {\n            \"format\": \"bool\",\n            \"value\": False\n        }\n    }\n    \n    errors = []\n    \n    for property_name, expected_info in expected_properties.items():\n        expected_value = expected_info['value']\n        expected_format = expected_info['format']\n        \n        if property_name not in properties:\n            errors.append(f\"{property_name} not found in input properties\")\n            continue\n        \n        actual_value = properties[property_name]\n        \n        # Check type (skip type check for np.allclose cases as it's handled separately)\n        if expected_format != \"np.allclose\" and not isinstance(actual_value, eval(expected_format)):\n            errors.append(f\"{property_name} is not of type {expected_format}\")\n            continue\n        \n        # Check value or use np.allclose for approximate comparisons\n        if expected_format == \"np.allclose\":\n            if not np.allclose(actual_value, expected_value):\n                errors.append(f\"{property_name}: Expected value close to {expected_value} but got {actual_value}\")\n        else:\n            if actual_value != expected_value:\n                errors.append(f\"{property_name}: Expected {expected_value} but got {actual_value}\")\n    \n    if errors:\n        print(\"failed:\", \"; \".join(errors))\n    else:\n        print(\"ok\")"
    },
    {
        "properties_json_str": "{\n  \"JSON_File_Name\": \"test_get_local_extrema\",\n  \"properties\": {\n    \"local_extrema_positions\": {\n      \"description\": \"Identifies the fractional coordinates of local minima in the charge density data of a material structure.\",\n      \"format\": \"np.allclose (list of fractional coordinates)\",\n      \"value\": \"[[0, 0, 0], [0.25, 0.25, 0.25], [0.5, 0.5, 0.5], [0.75, 0.75, 0.75]]\"\n    }\n  }\n}",
        "question": "As a materials scientist, you are utilizing Pymatgen to write functions to calculate material properties. Here is what you need to do:\n- Calculate the following properties:\n    - `local_extrema_positions`: Identifies the fractional coordinates of local minima in the charge density data of a material structure. The format should be a list of fractional coordinates that are close to the expected values using `np.allclose`.\n\nIf you need to read files or generate data, please refer to the following instructions:\n- Read or Generate Data:\n    - Access the structure file at: `<path>tool_source_code/pymatgen-analysis-defects/tests/test_files/GaN.vasp</path>`.\n    - Use the Pymatgen function:\n    ```python\n    from pymatgen.core import Structure\n    gan_struct = Structure.from_file(file_path / \"GaN.vasp\")\n    ```\n    - Generate charge density data using:\n    ```python\n    import numpy as np\n    from pymatgen.io.vasp.outputs import Chgcar\n    data = np.ones((48, 48, 48))\n    chgcar = Chgcar(poscar=gan_struct, data={\"total\": data})\n    frac_pos = [[0, 0, 0], [0.25, 0.25, 0.25], [0.5, 0.5, 0.5], [0.75, 0.75, 0.75]]\n    for fpos in frac_pos:\n        idx = np.multiply(fpos, chgcar.data[\"total\"].shape).astype(int)\n        chgcar.data[\"total\"][idx[0], idx[1], idx[2]] = 0\n    ```\n    - Use the Pymatgen function to find local extrema:\n    ```python\n    from pymatgen.analysis.defects.utils import get_local_extrema\n    loc_min = get_local_extrema(chgcar, frac_pos)\n    ```\n\nAll content is executed within the function, and the function does not require any input to output the result. The format of the function should follow these guidelines:\n- Write a Python function that:\n    - Reads the data from the provided file paths or generates data based on the description in the first section.\n    - Calculates all the properties mentioned above using Pymatgen.\n    - Returns a dictionary where the property names are keys, and the calculated results are the values.\n\n- Ensure your function includes:\n    - Necessary imports (e.g., `from pymatgen.core import Structure`).\n    - Proper file handling or data generation code.\n    - Output in the form of a dictionary as specified above.\n    - A complete docstring with clear input parameters, data types, and a description of the output.\n\n**Write the required Python function for this task**.",
        "new_unit_test": "def test_get_local_extrema(properties):\n    import numpy as np\n    expected_properties = {\n        \"local_extrema_positions\": {\n            \"format\": \"np.allclose\",\n            \"value\": [[0, 0, 0], [0.25, 0.25, 0.25], [0.5, 0.5, 0.5], [0.75, 0.75, 0.75]]\n        }\n    }\n    \n    errors = []\n    \n    for property_name, expected_info in expected_properties.items():\n        expected_value = expected_info['value']\n        expected_format = expected_info['format']\n        \n        if property_name not in properties:\n            errors.append(f\"{property_name} not found in input properties\")\n            continue\n        \n        actual_value = properties[property_name]\n        \n        # Check value or use np.allclose for approximate comparisons\n        if expected_format == \"np.allclose\":\n            if not np.allclose(actual_value, expected_value):\n                errors.append(f\"{property_name}: Expected value close to {expected_value} but got {actual_value}\")\n        else:\n            if actual_value != expected_value:\n                errors.append(f\"{property_name}: Expected {expected_value} but got {actual_value}\")\n    \n    if errors:\n        print(\"failed:\", \"; \".join(errors))\n    else:\n        print(\"ok\")"
    },
    {
        "properties_json_str": "{\n  \"JSON_File_Name\": \"test_cluster_nodes\",\n  \"properties\": {\n    \"clustered_positions\": {\n      \"description\": \"This property tests the ability to cluster fractional positions in a crystal lattice, ensuring that positions close to each other are grouped together.\",\n      \"format\": \"np.allclose (list of lists of floats)\",\n      \"value\": \"[[0, 0, 0], [0.25, 0.25, 0.25], [0.5, 0.5, 0.5], [0.75, 0.75, 0.75]]\"\n    }\n  }\n}",
        "question": "As a materials scientist, you are utilizing Pymatgen to write functions to calculate material properties. Here is what you need to do:\n- Calculate the following properties:\n    - `clustered_positions`: This property tests the ability to cluster fractional positions in a crystal lattice, ensuring that positions close to each other are grouped together. The format is a list of lists of floats, and the expected value is `[[0, 0, 0], [0.25, 0.25, 0.25], [0.5, 0.5, 0.5], [0.75, 0.75, 0.75]]`.\n\nIf you need to read files or generate data, please refer to the following instructions:\n- Read or Generate Data:\n    - Access the structure file at: `<path>tool_source_code/pymatgen-analysis-defects/tests/test_files/GaN.vasp</path>`.\n    - Use the Pymatgen function:\n    ```python\n    from pymatgen.core import Structure\n    gan_struct = Structure.from_file(file_path / \"GaN.vasp\")\n    ```\n    - Use the Pymatgen function:\n    ```python\n    from pymatgen.analysis.defects.utils import cluster_nodes\n    frac_pos = [\n        [0, 0, 0],\n        [0.25, 0.25, 0.25],\n        [0.5, 0.5, 0.5],\n        [0.75, 0.75, 0.75],\n    ]\n    added = [\n        [0.0002, 0.0001, 0.0001],\n        [0.0002, 0.0002, 0.0003],\n        [0.25001, 0.24999, 0.24999],\n        [0.25, 0.249999, 0.250001],\n    ]\n    clusters = cluster_nodes(frac_pos + added, gan_struct.lattice)\n    ```\n\nAll content is executed within the function, and the function does not require any input to output the result. The format of the function should follow these guidelines:\n- Write a Python function that:\n    - Reads the data from the provided file paths or generate data based on the description in the first section.\n    - Calculates all the properties mentioned above using Pymatgen.\n    - Returns a dictionary where the property names are keys, and the calculated results are the values.\n\n- Ensure your function includes:\n    - Necessary imports (e.g., `from pymatgen.core import Structure`).\n    - Proper file handling or data generation code.\n    - Output in the form of a dictionary as specified above.\n    - A complete docstring with clear input parameters, data types, and a description of the output.\n\n**Write the required Python function for this task**.",
        "new_unit_test": "def test_cluster_nodes(properties):\n    import numpy as np\n    expected_properties = {\n        \"clustered_positions\": {\n            \"format\": \"np.allclose\",\n            \"value\": [[0, 0, 0], [0.25, 0.25, 0.25], [0.5, 0.5, 0.5], [0.75, 0.75, 0.75]]\n        }\n    }\n    \n    errors = []\n    \n    for property_name, expected_info in expected_properties.items():\n        expected_value = expected_info['value']\n        expected_format = expected_info['format']\n        \n        if property_name not in properties:\n            errors.append(f\"{property_name} not found in input properties\")\n            continue\n        \n        actual_value = properties[property_name]\n        \n        # Check value or use np.allclose for approximate comparisons\n        if expected_format == \"np.allclose\":\n            if not np.allclose(actual_value, expected_value):\n                errors.append(f\"{property_name}: Expected value close to {expected_value} but got {actual_value}\")\n        else:\n            if actual_value != expected_value:\n                errors.append(f\"{property_name}: Expected {expected_value} but got {actual_value}\")\n    \n    if errors:\n        print(\"failed:\", \"; \".join(errors))\n    else:\n        print(\"ok\")"
    },
    {
        "properties_json_str": "{\n  \"JSON_File_Name\": \"test_get_avg_chg\",\n  \"properties\": {\n    \"average_charge_density\": {\n      \"description\": \"The average charge density within a spherical region of a crystal structure, calculated using charge density data from a CHGCAR file.\",\n      \"format\": \"np.allclose (approximate comparison of float values)\",\n      \"value\": \"0.0004340277777777778\"\n    }\n  }\n}",
        "question": "As a materials scientist, you are utilizing Pymatgen to write functions to calculate material properties. Here is what you need to do:\n- Calculate the following properties:\n    - `average_charge_density`: The average charge density within a spherical region of a crystal structure, calculated using charge density data from a CHGCAR file. The result should be a float value.\n\nIf you need to read files or generate data, please refer to the following instructions:\n- Read or Generate Data:\n    - Access the structure file at: `<path>tool_source_code/pymatgen-analysis-defects/tests/test_files/GaN.vasp</path>`.\n    - Use the Pymatgen function:\n    ```python\n    from pymatgen.core import Structure\n    gan_struct = Structure.from_file(file_path / \"GaN.vasp\")\n    ```\n    - Generate charge density data using:\n    ```python\n    import numpy as np\n    from pymatgen.io.vasp.outputs import Chgcar\n    data = np.ones((48, 48, 48))\n    chgcar = Chgcar(poscar=gan_struct, data={\"total\": data})\n    ```\n    - Calculate the average charge density using:\n    ```python\n    from pymatgen.analysis.defects.utils import get_avg_chg\n    fpos = [0.1, 0.1, 0.1]\n    avg_chg_sphere = get_avg_chg(chgcar, fpos)\n    ```\n\nAll content is executed within the function, and the function does not require any input to output the result. The format of the function should follow these guidelines:\n- Write a Python function that:\n    - Reads the data from the provided file paths or generate data based on the description in the first section.\n    - Calculates all the properties mentioned above using Pymatgen.\n    - Returns a dictionary where the property names are keys, and the calculated results are the values.\n\n- Ensure your function includes:\n    - Necessary imports (e.g., `from pymatgen.core import Structure`).\n    - Proper file handling or data generation code.\n    - Output in the form of a dictionary as specified above.\n    - A complete docstring with clear input parameters, data types, and a description of the output.\n\n**Write the required Python function for this task**.",
        "new_unit_test": "def test_get_avg_chg(properties):\n    import numpy as np\n    expected_properties = {\n        \"average_charge_density\": {\n            \"format\": \"np.allclose\",\n            \"value\": 0.0004340277777777778\n        }\n    }\n    \n    errors = []\n    \n    for property_name, expected_info in expected_properties.items():\n        expected_value = expected_info['value']\n        expected_format = expected_info['format']\n        \n        if property_name not in properties:\n            errors.append(f\"{property_name} not found in input properties\")\n            continue\n        \n        actual_value = properties[property_name]\n        \n        # Check value using np.allclose for approximate comparisons\n        if expected_format == \"np.allclose\":\n            if not np.allclose(actual_value, expected_value):\n                errors.append(f\"{property_name}: Expected value close to {expected_value} but got {actual_value}\")\n        else:\n            if actual_value != expected_value:\n                errors.append(f\"{property_name}: Expected {expected_value} but got {actual_value}\")\n    \n    if errors:\n        print(\"failed:\", \"; \".join(errors))\n    else:\n        print(\"ok\")"
    },
    {
        "properties_json_str": "{\n  \"JSON_File_Name\": \"test_chgcar_insertion\",\n  \"properties\": {\n    \"average_charge\": {\n      \"description\": \"The average charge at specific insertion sites within the material structure.\",\n      \"format\": \"float\",\n      \"value\": \"0.03692438178614583\"\n    },\n    \"insertion_site_positions\": {\n      \"description\": \"Fractional coordinates of the insertion sites within the crystal lattice.\",\n      \"format\": \"np.allclose (list of lists of floats)\",\n      \"value\": \"[[0.0, 0.0, 0.0], [0.0, 0.0, 0.5], [0.0, 0.5, 0.0], [0.5, 0.0, 0.0]]\"\n    }\n  }\n}",
        "question": "As a materials scientist, you are utilizing Pymatgen to write functions to calculate material properties. Here is what you need to do:\n- Calculate the following properties:\n    - `average_charge`: The average charge at specific insertion sites within the material structure. The format is a float.\n    - `insertion_site_positions`: Fractional coordinates of the insertion sites within the crystal lattice. The format is a list of lists of floats.\n\nIf you need to read files or generate data, please refer to the following instructions:\n- Read or Generate Data:\n    - Access the CHGCAR file at: `<path>tool_source_code/pymatgen-analysis-defects/tests/test_files/CHGCAR.Fe3O4.vasp</path>`.\n    - Use the Pymatgen function ```python\\nfrom pymatgen.io.vasp.outputs import Chgcar\\nChgcar.from_file(file_path / \"CHGCAR.Fe3O4.vasp\")\\n``` to read the charge density data.\n    - Use the Pymatgen function ```python\\nfrom pymatgen.analysis.defects.utils import ChargeInsertionAnalyzer\\ncia = ChargeInsertionAnalyzer(chgcar)\\ninsert_groups = cia.filter_and_group(max_avg_charge=0.5)\\n``` to analyze charge insertion sites.\n\nAll content is executed within the function, and the function does not require any input to output the result. The format of the function should follow these guidelines:\n- Write a Python function that:\n    - Reads the data from the provided file paths or generate data based on the description in the first section.\n    - Calculates all the properties mentioned above using Pymatgen.\n    - Returns a dictionary where the property names are keys, and the calculated results are the values.\n\n- Ensure your function includes:\n    - Necessary imports (e.g., `from pymatgen.io.vasp.outputs import Chgcar`).\n    - Proper file handling or data generation code.\n    - Output in the form of a dictionary as specified above.\n    - A complete docstring with clear input parameters, data types, and a description of the output.\n\n**Write the required Python function for this task**.",
        "new_unit_test": "def test_chgcar_insertion(properties):\n    import numpy as np\n    expected_properties = {\n        \"average_charge\": {\n            \"format\": \"float\",\n            \"value\": 0.03692438178614583\n        },\n        \"insertion_site_positions\": {\n            \"format\": \"np.allclose\",\n            \"value\": [[0.0, 0.0, 0.0], [0.0, 0.0, 0.5], [0.0, 0.5, 0.0], [0.5, 0.0, 0.0]]\n        }\n    }\n    \n    errors = []\n    \n    for property_name, expected_info in expected_properties.items():\n        expected_value = expected_info['value']\n        expected_format = expected_info['format']\n        \n        if property_name not in properties:\n            errors.append(f\"{property_name} not found in input properties\")\n            continue\n        \n        actual_value = properties[property_name]\n        \n        # Check type (skip type check for np.allclose cases as it's handled separately)\n        if expected_format != \"np.allclose\" and not isinstance(actual_value, eval(expected_format)):\n            errors.append(f\"{property_name} is not of type {expected_format}\")\n            continue\n        \n        # Check value or use np.allclose for approximate comparisons\n        if expected_format == \"np.allclose\":\n            if not np.allclose(actual_value, expected_value):\n                errors.append(f\"{property_name}: Expected value close to {expected_value} but got {actual_value}\")\n        else:\n            if actual_value != expected_value:\n                errors.append(f\"{property_name}: Expected {expected_value} but got {actual_value}\")\n    \n    if errors:\n        print(\"failed:\", \"; \".join(errors))\n    else:\n        print(\"ok\")"
    },
    {
        "properties_json_str": "{\n  \"JSON_File_Name\": \"test_topography_analyzer\",\n  \"properties\": {\n    \"dummy_sites_count\": {\n      \"description\": \"The number of dummy sites with species X in the structure after topography analysis.\",\n      \"format\": \"int\",\n      \"value\": 100\n    },\n    \"value_error_check\": {\n      \"description\": \"Ensures that a ValueError is raised when the TopographyAnalyzer is initialized with conflicting species lists.\",\n      \"format\": \"bool\",\n      \"value\": \"raises ValueError\"\n    }\n  }\n}",
        "question": "As a materials scientist, you are utilizing Pymatgen to write functions to calculate material properties. Here is what you need to do:\n- Calculate the following properties:\n    - `dummy_sites_count`: The number of dummy sites with species X in the structure after topography analysis. The format is an integer.\n    - `value_error_check`: Ensures that a ValueError is raised when the TopographyAnalyzer is initialized with conflicting species lists. The format is a boolean indicating whether the error is raised.\n\nIf you need to read files or generate data, please refer to the following instructions:\n- Read or Generate Data:\n    - Access the CHGCAR file for Fe3O4 at: `<path>tool_source_code/pymatgen-analysis-defects/tests/test_files/CHGCAR.Fe3O4.vasp</path>`.\n    - Use the Pymatgen function ```python\\nfrom pymatgen.io.vasp.outputs import Chgcar\\nChgcar.from_file(file_path / \"CHGCAR.Fe3O4.vasp\")\\n``` to read the charge density data.\n\nAll content is executed within the function, and the function does not require any input to output the result. The format of the function should follow these guidelines:\n- Write a Python function that:\n    - Reads the data from the provided file paths or generates data based on the description in the first section.\n    - Calculates all the properties mentioned above using Pymatgen.\n    - Returns a dictionary where the property names are keys, and the calculated results are the values.\n\n- Ensure your function includes:\n    - Necessary imports (e.g., `from pymatgen.io.vasp.outputs import Chgcar`).\n    - Proper file handling or data generation code.\n    - Output in the form of a dictionary as specified above.\n    - A complete docstring with clear input parameters, data types, and a description of the output.\n\n**Write the required Python function for this task**.",
        "new_unit_test": "def test_topography_analyzer(properties):\n    import numpy as np\n    expected_properties = {\n        \"dummy_sites_count\": {\n            \"format\": \"int\",\n            \"value\": 100\n        },\n        \"value_error_check\": {\n            \"format\": \"bool\",\n            \"value\": \"raises ValueError\"\n        }\n    }\n    \n    errors = []\n    \n    for property_name, expected_info in expected_properties.items():\n        expected_value = expected_info['value']\n        expected_format = expected_info['format']\n        \n        if property_name not in properties:\n            errors.append(f\"{property_name} not found in input properties\")\n            continue\n        \n        actual_value = properties[property_name]\n        \n        # Check type (skip type check for special cases like exception checks)\n        if expected_format != \"np.allclose\" and expected_value != \"raises ValueError\" and not isinstance(actual_value, eval(expected_format)):\n            errors.append(f\"{property_name} is not of type {expected_format}\")\n            continue\n        \n        # Check value or use np.allclose for approximate comparisons\n        if expected_value == \"raises ValueError\":\n            try:\n                # Assuming actual_value is a callable that should raise ValueError\n                actual_value()\n                errors.append(f\"{property_name}: Expected to raise ValueError but it did not\")\n            except ValueError:\n                pass  # Expected exception, so pass\n            except Exception as e:\n                errors.append(f\"{property_name}: Expected to raise ValueError but raised {type(e).__name__}\")\n        elif expected_format == \"np.allclose\":\n            if not np.allclose(actual_value, expected_value):\n                errors.append(f\"{property_name}: Expected value close to {expected_value} but got {actual_value}\")\n        else:\n            if actual_value != expected_value:\n                errors.append(f\"{property_name}: Expected {expected_value} but got {actual_value}\")\n    \n    if errors:\n        print(\"failed:\", \"; \".join(errors))\n    else:\n        print(\"ok\")"
    },
    {
        "properties_json_str": "{\n  \"JSON_File_Name\": \"test_get_localized_states\",\n  \"properties\": {\n    \"localized_bands_set_1\": {\n      \"description\": \"Set of band indices identified as localized states in the band structure for a specific defect configuration.\",\n      \"format\": \"set\",\n      \"value\": \"{138}\"\n    },\n    \"localized_bands_set_2\": {\n      \"description\": \"Set of band indices identified as localized states in the band structure for another defect configuration with a specified band window.\",\n      \"format\": \"set\",\n      \"value\": \"{75, 77}\"\n    }\n  }\n}",
        "question": "As a materials scientist, you are utilizing Pymatgen to write functions to calculate material properties. Here is what you need to do:\n- Calculate the following properties:\n    - `localized_bands_set_1`: Set of band indices identified as localized states in the band structure for a specific defect configuration. The format is a set, e.g., `{138}`.\n    - `localized_bands_set_2`: Set of band indices identified as localized states in the band structure for another defect configuration with a specified band window. The format is a set, e.g., `{75, 77}`.\n\nIf you need to read files or generate data, please refer to the following instructions:\n- Read or Generate Data:\n    - Access the directory containing the necessary files at: `<path>tool_source_code/pymatgen-analysis-defects/tests/test_files/v_Ga/ccd_0_-1</path>` and `<path>tool_source_code/pymatgen-analysis-defects/tests/test_files/v_Ga/ccd_-1_0</path>`.\n    - Use the Pymatgen function to read the Vasprun and Procar files:\n      ```python\n      from pymatgen.io.vasp.outputs import Vasprun, Procar\n      vaspruns_0_1 = [Vasprun(\"<path>tool_source_code/pymatgen-analysis-defects/tests/test_files/v_Ga/ccd_0_-1/0/vasprun.xml</path>\"),\n                      Vasprun(\"<path>tool_source_code/pymatgen-analysis-defects/tests/test_files/v_Ga/ccd_0_-1/1/vasprun.xml</path>\"),\n                      Vasprun(\"<path>tool_source_code/pymatgen-analysis-defects/tests/test_files/v_Ga/ccd_0_-1/2/vasprun.xml</path>\")]\n      procar_0_1 = Procar(\"<path>tool_source_code/pymatgen-analysis-defects/tests/test_files/v_Ga/ccd_0_-1/1/PROCAR</path>\")\n      \n      vaspruns_1_0 = [Vasprun(\"<path>tool_source_code/pymatgen-analysis-defects/tests/test_files/v_Ga/ccd_-1_0/0/vasprun.xml</path>\"),\n                      Vasprun(\"<path>tool_source_code/pymatgen-analysis-defects/tests/test_files/v_Ga/ccd_-1_0/1/vasprun.xml</path>\"),\n                      Vasprun(\"<path>tool_source_code/pymatgen-analysis-defects/tests/test_files/v_Ga/ccd_-1_0/2/vasprun.xml</path>\")]\n      procar_1_0 = Procar(\"<path>tool_source_code/pymatgen-analysis-defects/tests/test_files/v_Ga/ccd_-1_0/1/PROCAR</path>\")\n      ```\n\nAll content is executed within the function, and the function does not require any input to output the result. The format of the function should follow these guidelines:\n- Write a Python function that:\n    - Reads the data from the provided file paths.\n    - Calculates all the properties mentioned above using Pymatgen.\n    - Returns a dictionary where the property names are keys, and the calculated results are the values.\n\n- Ensure your function includes:\n    - Necessary imports (e.g., `from pymatgen.io.vasp.outputs import Vasprun, Procar`).\n    - Proper file handling or data generation code.\n    - Output in the form of a dictionary as specified above.\n    - A complete docstring with clear input parameters, data types, and a description of the output.\n\n**Write the required Python function for this task**.",
        "new_unit_test": "def test_get_localized_states(properties):\n    import numpy as np\n    expected_properties = {\n        \"localized_bands_set_1\": {\n            \"format\": \"set\",\n            \"value\": {138}\n        },\n        \"localized_bands_set_2\": {\n            \"format\": \"set\",\n            \"value\": {75, 77}\n        }\n    }\n    \n    errors = []\n    \n    for property_name, expected_info in expected_properties.items():\n        expected_value = expected_info['value']\n        expected_format = expected_info['format']\n        \n        if property_name not in properties:\n            errors.append(f\"{property_name} not found in input properties\")\n            continue\n        \n        actual_value = properties[property_name]\n        \n        # Check type\n        if not isinstance(actual_value, eval(expected_format)):\n            errors.append(f\"{property_name} is not of type {expected_format}\")\n            continue\n        \n        # Check value\n        if actual_value != expected_value:\n            errors.append(f\"{property_name}: Expected {expected_value} but got {actual_value}\")\n    \n    if errors:\n        print(\"failed:\", \"; \".join(errors))\n    else:\n        print(\"ok\")"
    },
    {
        "properties_json_str": "{\n  \"JSON_File_Name\": \"test_group_docs\",\n  \"properties\": {\n    \"defect_grouping_without_key_function\": {\n      \"description\": \"Tests the grouping of defects based on their structure without using a key function, ensuring that defects at inequivalent sites are grouped separately.\",\n      \"format\": \"str\",\n      \"value\": \"N_i|N_i|v_Ga,v_Ga|v_N,v_N\"\n    },\n    \"defect_grouping_with_key_function\": {\n      \"description\": \"Tests the grouping of defects based on both their structure and name using a key function, ensuring that defects are grouped correctly by both criteria.\",\n      \"format\": \"str\",\n      \"value\": \"N_i|N_i,N_i|v_Ga,v_Ga|v_N,v_N\"\n    },\n    \"group_names_with_key_function\": {\n      \"description\": \"Verifies the names of groups formed when defects are grouped by both structure and name using a key function.\",\n      \"format\": \"str\",\n      \"value\": \"N_i:0|N_i:1|v_Ga|v_N\"\n    }\n  }\n}",
        "question": "As a materials scientist, you are utilizing Pymatgen to write functions to calculate material properties. Here is what you need to do:\n- Calculate the following properties:\n    - `defect_grouping_without_key_function`: Tests the grouping of defects based on their structure without using a key function, ensuring that defects at inequivalent sites are grouped separately. The format is a string.\n    - `defect_grouping_with_key_function`: Tests the grouping of defects based on both their structure and name using a key function, ensuring that defects are grouped correctly by both criteria. The format is a string.\n    - `group_names_with_key_function`: Verifies the names of groups formed when defects are grouped by both structure and name using a key function. The format is a string.\n\nIf you need to read files or generate data, please refer to the following instructions:\n- Read or Generate Data:\n    - Access the structure file at: `<path>tool_source_code/pymatgen-analysis-defects/tests/test_files/GaN.vasp</path>`.\n    - Use the Pymatgen function:\n    ```python\n    from pymatgen.core import Structure\n    gan_struct = Structure.from_file(file_path / \"GaN.vasp\")\n    ```\n    - Generate defects and group them using the following Pymatgen methods:\n    ```python\n    from pymatgen.analysis.defects.core import Interstitial, PeriodicSite, Vacancy\n    from pymatgen.analysis.structure_matcher import StructureMatcher\n    from pymatgen.core.periodic_table import Specie\n    from pymatgen.analysis.defects.utils import group_docs\n\n    s = gan_struct.copy()\n    vac1 = Vacancy(s, s.sites[0])\n    vac2 = Vacancy(s, s.sites[1])\n    vac3 = Vacancy(s, s.sites[2])\n    vac4 = Vacancy(s, s.sites[3])\n\n    def get_interstitial(fpos):\n        n_site = PeriodicSite(Specie(\"N\"), fpos, s.lattice)\n        return Interstitial(s, n_site)\n\n    int1 = get_interstitial([0.0, 0.0, 0.0])\n    int2 = get_interstitial([0.0, 0.0, 0.25])\n    sm = StructureMatcher()\n    ```\n\nAll content is executed within the function, and the function does not require any input to output the result. The format of the function should follow these guidelines:\n- Write a Python function that:\n    - Reads the data from the provided file paths or generates data based on the description in the first section.\n    - Calculates all the properties mentioned above using Pymatgen.\n    - Returns a dictionary where the property names are keys, and the calculated results are the values.\n\n- Ensure your function includes:\n    - Necessary imports (e.g., `from pymatgen.core import Structure`).\n    - Proper file handling or data generation code.\n    - Output in the form of a dictionary as specified above.\n    - A complete docstring with clear input parameters, data types, and a description of the output.\n\n**Write the required Python function for this task**.",
        "new_unit_test": "def test_test_group_docs(properties):\n    import numpy as np\n    expected_properties = {\n        \"defect_grouping_without_key_function\": {\n            \"format\": \"str\",\n            \"value\": \"N_i|N_i|v_Ga,v_Ga|v_N,v_N\"\n        },\n        \"defect_grouping_with_key_function\": {\n            \"format\": \"str\",\n            \"value\": \"N_i|N_i,N_i|v_Ga,v_Ga|v_N,v_N\"\n        },\n        \"group_names_with_key_function\": {\n            \"format\": \"str\",\n            \"value\": \"N_i:0|N_i:1|v_Ga|v_N\"\n        }\n    }\n    \n    errors = []\n    \n    for property_name, expected_info in expected_properties.items():\n        expected_value = expected_info['value']\n        expected_format = expected_info['format']\n        \n        if property_name not in properties:\n            errors.append(f\"{property_name} not found in input properties\")\n            continue\n        \n        actual_value = properties[property_name]\n        \n        # Check type\n        if not isinstance(actual_value, eval(expected_format)):\n            errors.append(f\"{property_name} is not of type {expected_format}\")\n            continue\n        \n        # Check value\n        if actual_value != expected_value:\n            errors.append(f\"{property_name}: Expected {expected_value} but got {actual_value}\")\n    \n    if errors:\n        print(\"failed:\", \"; \".join(errors))\n    else:\n        print(\"ok\")"
    },
    {
        "properties_json_str": "{\n  \"JSON_File_Name\": \"test_plane_spacing\",\n  \"properties\": {\n    \"plane_spacing\": {\n      \"description\": \"The distance between parallel planes in a crystal lattice, which is crucial for understanding diffraction patterns and material properties.\",\n      \"format\": \"np.allclose (list of float values for approximate comparison)\",\n      \"value\": \"[2.785, 2.785, 5.239]\"\n    }\n  }\n}",
        "question": "As a materials scientist, you are utilizing Pymatgen to write functions to calculate material properties. Here is what you need to do:\n- Calculate the following properties:\n    - `plane_spacing`: The distance between parallel planes in a crystal lattice, which is crucial for understanding diffraction patterns and material properties. The format should be a list of float values for approximate comparison using `np.allclose`.\n\nIf you need to read files or generate data, please refer to the following instructions:\n- Read or Generate Data:\n    - Access the structure file at: `<path>tool_source_code/pymatgen-analysis-defects/tests/test_files/GaN.vasp</path>`.\n    - Use the Pymatgen function:\n    ```python\n    from pymatgen.core import Structure\n    gan_struct = Structure.from_file(file_path / \"GaN.vasp\")\n    ```\n    to read the structure data.\n\nAll content is executed within the function, and the function does not require any input to output the result. The format of the function should follow these guidelines:\n- Write a Python function that:\n    - Reads the data from the provided file paths or generates data based on the description in the first section.\n    - Calculates all the properties mentioned above using Pymatgen.\n    - Returns a dictionary where the property names are keys, and the calculated results are the values.\n\n- Ensure your function includes:\n    - Necessary imports (e.g., `from pymatgen.core import Structure`).\n    - Proper file handling or data generation code.\n    - Output in the form of a dictionary as specified above.\n    - A complete docstring with clear input parameters, data types, and a description of the output.\n\n**Write the required Python function for this task**.",
        "new_unit_test": "def test_test_plane_spacing(properties):\n    import numpy as np\n    expected_properties = {\n        \"plane_spacing\": {\n            \"format\": \"np.allclose\",\n            \"value\": [2.785, 2.785, 5.239]\n        }\n    }\n    \n    errors = []\n    \n    for property_name, expected_info in expected_properties.items():\n        expected_value = expected_info['value']\n        expected_format = expected_info['format']\n        \n        if property_name not in properties:\n            errors.append(f\"{property_name} not found in input properties\")\n            continue\n        \n        actual_value = properties[property_name]\n        \n        # Check value using np.allclose for approximate comparisons\n        if expected_format == \"np.allclose\":\n            if not np.allclose(actual_value, expected_value):\n                errors.append(f\"{property_name}: Expected value close to {expected_value} but got {actual_value}\")\n        else:\n            if actual_value != expected_value:\n                errors.append(f\"{property_name}: Expected {expected_value} but got {actual_value}\")\n    \n    if errors:\n        print(\"failed:\", \"; \".join(errors))\n    else:\n        print(\"ok\")"
    },
    {
        "properties_json_str": "{\n  \"JSON_File_Name\": \"test_boltzmann\",\n  \"properties\": {\n    \"Boltzmann Filling Distribution\": {\n      \"description\": \"The Boltzmann filling distribution describes the probability of occupancy of energy states at a given temperature, following the Boltzmann distribution.\",\n      \"format\": \"np.allclose (list of float values for approximate comparison)\",\n      \"value\": \"[0.9791034813819097, 0.020459854127734073, 0.00042753972270360594, 8.934091775449048e-06, 1.8669141512139823e-07, 3.901200631921917e-09]\"\n    }\n  }\n}",
        "question": "As a materials scientist, you are utilizing Pymatgen to write functions to calculate material properties. Here is what you need to do:\n- Calculate the following properties:\n    - `Boltzmann Filling Distribution`: The Boltzmann filling distribution describes the probability of occupancy of energy states at a given temperature, following the Boltzmann distribution. The format is a list of float values for approximate comparison.\n\nIf you need to read files or generate data, please refer to the following instructions:\n- Read or Generate Data:\n    - Use the Pymatgen function ```python\\nfrom pymatgen.analysis.defects.recombination import boltzmann_filling\\nboltzmann_filling(0.1, 300, n_states=6)\\n``` to calculate the Boltzmann filling distribution for a temperature of 300 K and 6 energy states.\n\nAll content is executed within the function, and the function does not require any input to output the result. The format of the function should follow these guidelines:\n- Write a Python function that:\n    - Reads the data from the provided file paths or generate data based on the description in the first section.\n    - Calculates all the properties mentioned above using Pymatgen.\n    - Returns a dictionary where the property names are keys, and the calculated results are the values.\n\n- Ensure your function includes:\n    - Necessary imports (e.g., `from pymatgen.analysis.defects.recombination import boltzmann_filling`).\n    - Proper file handling or data generation code.\n    - Output in the form of a dictionary as specified above.\n    - A complete docstring with clear input parameters, data types, and a description of the output.\n\n**Write the required Python function for this task**.",
        "new_unit_test": "def test_boltzmann(properties):\n    import numpy as np\n    expected_properties = {\n        \"Boltzmann Filling Distribution\": {\n            \"format\": \"np.allclose\",\n            \"value\": [0.9791034813819097, 0.020459854127734073, 0.00042753972270360594, 8.934091775449048e-06, 1.8669141512139823e-07, 3.901200631921917e-09]\n        }\n    }\n    \n    errors = []\n    \n    for property_name, expected_info in expected_properties.items():\n        expected_value = expected_info['value']\n        expected_format = expected_info['format']\n        \n        if property_name not in properties:\n            errors.append(f\"{property_name} not found in input properties\")\n            continue\n        \n        actual_value = properties[property_name]\n        \n        # Check value or use np.allclose for approximate comparisons\n        if expected_format == \"np.allclose\":\n            if not np.allclose(actual_value, expected_value):\n                errors.append(f\"{property_name}: Expected value close to {expected_value} but got {actual_value}\")\n        else:\n            if actual_value != expected_value:\n                errors.append(f\"{property_name}: Expected {expected_value} but got {actual_value}\")\n    \n    if errors:\n        print(\"failed:\", \"; \".join(errors))\n    else:\n        print(\"ok\")"
    },
    {
        "properties_json_str": "{\n  \"JSON_File_Name\": \"test_get_vibronic_matrix_elements\",\n  \"properties\": {\n    \"vibronic_matrix_elements\": {\n      \"description\": \"The vibronic matrix elements represent the coupling between electronic states and vibrational modes, calculated using the overlap of vibrational wavefunctions.\",\n      \"format\": \"np.allclose (list of float values for approximate comparison)\",\n      \"value\": \"[0.0, 3984589.0407885523, 0.0, 0.0, 0.0]\"\n    }\n  }\n}",
        "question": "As a materials scientist, you are utilizing Pymatgen to write functions to calculate material properties. Here is what you need to do:\n- Calculate the following properties:\n    - `vibronic_matrix_elements`: The vibronic matrix elements represent the coupling between electronic states and vibrational modes, calculated using the overlap of vibrational wavefunctions. The format is a list of float values for approximate comparison.\n\nIf you need to read files or generate data, please refer to the following instructions:\n- Read or Generate Data:\n    - Precompute values of the overlap using the Pymatgen function `analytic_overlap_NM` from `pymatgen.analysis.defects.recombination`.\n    - Use the Pymatgen function `get_mQn` from `pymatgen.analysis.defects.recombination` to calculate the vibronic matrix elements.\n\nAll content is executed within the function, and the function does not require any input to output the result. The format of the function should follow these guidelines:\n- Write a Python function that:\n    - Generates the necessary data using the provided Pymatgen functions.\n    - Calculates the vibronic matrix elements using Pymatgen.\n    - Returns a dictionary where the property name is the key, and the calculated result is the value.\n\n- Ensure your function includes:\n    - Necessary imports (e.g., `from pymatgen.analysis.defects.recombination import analytic_overlap_NM, get_mQn`).\n    - Proper data generation code.\n    - Output in the form of a dictionary as specified above.\n    - A complete docstring with clear input parameters, data types, and a description of the output.\n\n**Write the required Python function for this task**.",
        "new_unit_test": "def test_get_vibronic_matrix_elements(properties):\n    import numpy as np\n    expected_properties = {\n        \"vibronic_matrix_elements\": {\n            \"format\": \"np.allclose\",\n            \"value\": [0.0, 3984589.0407885523, 0.0, 0.0, 0.0]\n        }\n    }\n    \n    errors = []\n    \n    for property_name, expected_info in expected_properties.items():\n        expected_value = expected_info['value']\n        expected_format = expected_info['format']\n        \n        if property_name not in properties:\n            errors.append(f\"{property_name} not found in input properties\")\n            continue\n        \n        actual_value = properties[property_name]\n        \n        # Check value or use np.allclose for approximate comparisons\n        if expected_format == \"np.allclose\":\n            if not np.allclose(actual_value, expected_value):\n                errors.append(f\"{property_name}: Expected value close to {expected_value} but got {actual_value}\")\n        else:\n            if actual_value != expected_value:\n                errors.append(f\"{property_name}: Expected {expected_value} but got {actual_value}\")\n    \n    if errors:\n        print(\"failed:\", \"; \".join(errors))\n    else:\n        print(\"ok\")"
    },
    {
        "properties_json_str": "{\n  \"JSON_File_Name\": \"test_pchip_eval\",\n  \"properties\": {\n    \"pchip_interpolation_integral\": {\n      \"description\": \"This property tests the accuracy of the Piecewise Cubic Hermite Interpolating Polynomial (PCHIP) method by comparing the integral of the interpolated function to a reference value.\",\n      \"format\": \"np.allclose (approximate comparison)\",\n      \"value\": \"int_val == pytest.approx(int_ref, rel=1e-3)\"\n    }\n  }\n}",
        "question": "As a materials scientist, you are utilizing Pymatgen to write functions to calculate material properties. Here is what you need to do:\n- Calculate the following properties:\n    - `pchip_interpolation_integral`: This property tests the accuracy of the Piecewise Cubic Hermite Interpolating Polynomial (PCHIP) method by comparing the integral of the interpolated function to a reference value. The format is a boolean indicating if the integral of the interpolated function is approximately equal to the reference value.\n\nIf you need to read files or generate data, please refer to the following instructions:\n- Read or Generate Data:\n    - Generate a coarse grid of x-values and corresponding y-values using numpy. You should use the following code:\n    ```python\n    import numpy as np\n    x_c = np.linspace(0, 2, 5)\n    y_c = np.sin(x_c) + 1\n    ```\n    - Generate a fine grid of x-values for interpolation using numpy. You should use the following code:\n    ```python\n    xx = np.linspace(-3, 3, 1000)\n    ```\n    - Use the Pymatgen function `pchip_eval` to perform the interpolation:\n    ```python\n    from pymatgen.analysis.defects.recombination import pchip_eval\n    fx = pchip_eval(xx, x_coarse=x_c, y_coarse=y_c)\n    ```\n    - Calculate the integral of the interpolated function using numpy:\n    ```python\n    int_val = np.trapz(np.nan_to_num(fx), x=xx)\n    ```\n    - Calculate the reference integral value:\n    ```python\n    int_ref = np.sum(y_c)\n    ```\n\nAll content is executed within the function, and the function does not require any input to output the result. The format of the function should follow these guidelines:\n- Write a Python function that:\n    - Generates the data as described above.\n    - Calculates the property mentioned above using Pymatgen.\n    - Returns a dictionary where the property name is the key, and the calculated result is the value.\n\n- Ensure your function includes:\n    - Necessary imports (e.g., `import numpy as np`).\n    - Proper data generation code.\n    - Output in the form of a dictionary as specified above.\n    - A complete docstring with a description of the output.\n\n**Write the required Python function for this task**.",
        "new_unit_test": "def test_test_pchip_eval(properties):\n    import numpy as np\n    expected_properties = {\n        \"pchip_interpolation_integral\": {\n            \"format\": \"np.allclose\",\n            \"value\": \"int_val == pytest.approx(int_ref, rel=1e-3)\"\n        }\n    }\n    \n    errors = []\n    \n    for property_name, expected_info in expected_properties.items():\n        expected_value = expected_info['value']\n        expected_format = expected_info['format']\n        \n        if property_name not in properties:\n            errors.append(f\"{property_name} not found in input properties\")\n            continue\n        \n        actual_value = properties[property_name]\n        \n        # Check value using np.allclose for approximate comparisons\n        if expected_format == \"np.allclose\":\n            # Extract the expected value and tolerance from the string\n            # Assuming expected_value is a string like \"int_val == pytest.approx(int_ref, rel=1e-3)\"\n            # We need to evaluate this condition\n            try:\n                int_val, int_ref = actual_value\n                if not np.allclose(int_val, int_ref, rtol=1e-3):\n                    errors.append(f\"{property_name}: Expected value close to {int_ref} but got {int_val}\")\n            except Exception as e:\n                errors.append(f\"{property_name}: Error in evaluating np.allclose condition - {str(e)}\")\n        else:\n            errors.append(f\"{property_name}: Unsupported format {expected_format}\")\n    \n    if errors:\n        print(\"failed:\", \"; \".join(errors))\n    else:\n        print(\"ok\")"
    },
    {
        "properties_json_str": "{\n  \"JSON_File_Name\": \"test_get_SRH_coef\",\n  \"properties\": {\n    \"SRH_Coefficient\": {\n      \"description\": \"The Shockley-Read-Hall (SRH) recombination coefficient, which quantifies the rate of carrier recombination via defect states in a semiconductor.\",\n      \"format\": \"np.allclose (list of float values for approximate comparison)\",\n      \"value\": \"[4.64530153e-14, 4.64752885e-14, 4.75265302e-14]\"\n    }\n  }\n}",
        "question": "As a materials scientist, you are utilizing Pymatgen to write functions to calculate material properties. Here is what you need to do:\n- Calculate the following properties:\n    - `SRH_Coefficient`: The Shockley-Read-Hall (SRH) recombination coefficient, which quantifies the rate of carrier recombination via defect states in a semiconductor. The format should be a list of float values for approximate comparison.\n\nIf you need to read files or generate data, please refer to the following instructions:\n- Read or Generate Data:\n    - Access the structure file at: `<path>tool_source_code/pymatgen-analysis-defects/tests/test_files/GaN.vasp</path>`.\n    - Use the Pymatgen function ```python\\nfrom pymatgen.core import Structure\\nStructure.from_file(file_path / \"GaN.vasp\")\\n``` to read the structure data.\n\nAll content is executed within the function, and the function does not require any input to output the result. The format of the function should follow these guidelines:\n- Write a Python function that:\n    - Reads the data from the provided file paths or generate data based on the description in the first section.\n    - Calculates all the properties mentioned above using Pymatgen.\n    - Returns a dictionary where the property names are keys, and the calculated results are the values.\n\n- Ensure your function includes:\n    - Necessary imports (e.g., `from pymatgen.core import Structure`).\n    - Proper file handling or data generation code.\n    - Output in the form of a dictionary as specified above.\n    - A complete docstring with clear input parameters, data types, and a description of the output.\n\n**Write the required Python function for this task**.",
        "new_unit_test": "def test_get_SRH_coef(properties):\n    import numpy as np\n    expected_properties = {\n        \"SRH_Coefficient\": {\n            \"format\": \"np.allclose\",\n            \"value\": [4.64530153e-14, 4.64752885e-14, 4.75265302e-14]\n        }\n    }\n    \n    errors = []\n    \n    for property_name, expected_info in expected_properties.items():\n        expected_value = expected_info['value']\n        expected_format = expected_info['format']\n        \n        if property_name not in properties:\n            errors.append(f\"{property_name} not found in input properties\")\n            continue\n        \n        actual_value = properties[property_name]\n        \n        # Check value using np.allclose for approximate comparisons\n        if expected_format == \"np.allclose\":\n            if not np.allclose(actual_value, expected_value):\n                errors.append(f\"{property_name}: Expected value close to {expected_value} but got {actual_value}\")\n        else:\n            if actual_value != expected_value:\n                errors.append(f\"{property_name}: Expected {expected_value} but got {actual_value}\")\n    \n    if errors:\n        print(\"failed:\", \"; \".join(errors))\n    else:\n        print(\"ok\")"
    },
    {
        "properties_json_str": "{\n  \"JSON_File_Name\": \"test_get_Rad_coef\",\n  \"properties\": {\n    \"Radiative_Coefficient\": {\n      \"description\": \"Calculates the radiative recombination coefficient based on temperature, dipole moment, and other parameters.\",\n      \"format\": \"Function call with parameters (list, float, float, float, float, float, int, int, int)\",\n      \"value\": {\n        \"T\": [100, 200, 300],\n        \"dQ\": 1.0,\n        \"dE\": 1.0,\n        \"omega_i\": 0.2,\n        \"omega_f\": 0.2,\n        \"omega_photon\": 0.6,\n        \"dipole_me\": 1,\n        \"volume\": 1,\n        \"g\": 1\n      }\n    }\n  }\n}",
        "question": "As a materials scientist, you are utilizing Pymatgen to write functions to calculate material properties. Here is what you need to do:\n- Calculate the following properties:\n    - `Radiative_Coefficient`: Calculates the radiative recombination coefficient based on temperature, dipole moment, and other parameters. The function should be called with parameters (list, float, float, float, float, float, int, int, int).\n\nIf you need to read files or generate data, please refer to the following instructions:\n- Read or Generate Data:\n    - No file reading is required for this task as all necessary parameters are provided directly.\n\nAll content is executed within the function, and the function does not require any input to output the result. The format of the function should follow these guidelines:\n- Write a Python function that:\n    - Uses the provided parameters to calculate the radiative recombination coefficient using Pymatgen.\n    - Returns a dictionary where the property name is the key, and the calculated result is the value.\n\n- Ensure your function includes:\n    - Necessary imports (e.g., `from pymatgen.analysis.defects.recombination import get_Rad_coef`).\n    - Calculation code using the provided parameters.\n    - Output in the form of a dictionary as specified above.\n    - A complete docstring with a description of the output.\n\n**Write the required Python function for this task**.",
        "new_unit_test": "def test_get_Rad_coef(properties):\n    import numpy as np\n    expected_properties = {\n        \"Radiative_Coefficient\": {\n            \"format\": \"Function call with parameters (list, float, float, float, float, float, int, int, int)\",\n            \"value\": {\n                \"T\": [100, 200, 300],\n                \"dQ\": 1.0,\n                \"dE\": 1.0,\n                \"omega_i\": 0.2,\n                \"omega_f\": 0.2,\n                \"omega_photon\": 0.6,\n                \"dipole_me\": 1,\n                \"volume\": 1,\n                \"g\": 1\n            }\n        }\n    }\n    \n    errors = []\n    \n    for property_name, expected_info in expected_properties.items():\n        expected_value = expected_info['value']\n        expected_format = expected_info['format']\n        \n        if property_name not in properties:\n            errors.append(f\"{property_name} not found in input properties\")\n            continue\n        \n        actual_value = properties[property_name]\n        \n        # Check if the actual value is a dictionary with the expected keys\n        if not isinstance(actual_value, dict):\n            errors.append(f\"{property_name} is not a dictionary\")\n            continue\n        \n        for key, expected_key_value in expected_value.items():\n            if key not in actual_value:\n                errors.append(f\"{property_name}: Key {key} not found in actual value\")\n                continue\n            \n            actual_key_value = actual_value[key]\n            \n            # Determine the expected type based on the key\n            if isinstance(expected_key_value, list):\n                expected_type = list\n            elif isinstance(expected_key_value, float):\n                expected_type = float\n            elif isinstance(expected_key_value, int):\n                expected_type = int\n            else:\n                errors.append(f\"{property_name}: Unexpected type for key {key}\")\n                continue\n            \n            # Check type\n            if not isinstance(actual_key_value, expected_type):\n                errors.append(f\"{property_name}: Key {key} is not of type {expected_type.__name__}\")\n                continue\n            \n            # Check value\n            if expected_type == list:\n                if actual_key_value != expected_key_value:\n                    errors.append(f\"{property_name}: Key {key} expected {expected_key_value} but got {actual_key_value}\")\n            else:\n                if actual_key_value != expected_key_value:\n                    errors.append(f\"{property_name}: Key {key} expected {expected_key_value} but got {actual_key_value}\")\n    \n    if errors:\n        print(\"failed:\", \"; \".join(errors))\n    else:\n        print(\"ok\")"
    },
    {
        "properties_json_str": "{\n  \"JSON_File_Name\": \"test_vacancy_generators\",\n  \"properties\": {\n    \"defect_instance_type\": {\n      \"description\": \"Checks if the generated defect is an instance of the Vacancy class.\",\n      \"format\": \"bool\",\n      \"value\": \"True\"\n    },\n    \"vacancy_count_for_specific_species\": {\n      \"description\": \"Verifies the number of vacancies generated for a specific species, in this case, Gallium (Ga).\",\n      \"format\": \"int\",\n      \"value\": \"1\"\n    },\n    \"invalid_species_error\": {\n      \"description\": \"Ensures that a ValueError is raised when attempting to generate vacancies for a non-existent species, such as Xenon (Xe).\",\n      \"format\": \"bool\",\n      \"value\": \"True\"\n    }\n  }\n}",
        "question": "As a materials scientist, you are utilizing Pymatgen to write functions to calculate material properties. Here is what you need to do:\n- Calculate the following properties:\n    - `defect_instance_type`: Checks if the generated defect is an instance of the Vacancy class. The format is a boolean.\n    - `vacancy_count_for_specific_species`: Verifies the number of vacancies generated for a specific species, in this case, Gallium (Ga). The format is an integer.\n    - `invalid_species_error`: Ensures that a ValueError is raised when attempting to generate vacancies for a non-existent species, such as Xenon (Xe). The format is a boolean.\n\nIf you need to read files or generate data, please refer to the following instructions:\n- Read or Generate Data:\n    - Access the structure file at: `<path>tool_source_code/pymatgen-analysis-defects/tests/test_files/GaN.vasp</path>`.\n    - Use the Pymatgen function:\n    ```python\n    from pymatgen.core import Structure\n    gan_struct = Structure.from_file(file_path / \"GaN.vasp\")\n    ```\n    to read the structure data.\n\nAll content is executed within the function, and the function does not require any input to output the result. The format of the function should follow these guidelines:\n- Write a Python function that:\n    - Reads the data from the provided file paths or generates data based on the description in the first section.\n    - Calculates all the properties mentioned above using Pymatgen.\n    - Returns a dictionary where the property names are keys, and the calculated results are the values.\n\n- Ensure your function includes:\n    - Necessary imports (e.g., `from pymatgen.core import Structure`).\n    - Proper file handling or data generation code.\n    - Output in the form of a dictionary as specified above.\n    - A complete docstring with clear input parameters, data types, and a description of the output.\n\n**Write the required Python function for this task**.",
        "new_unit_test": "def test_vacancy_generators(properties):\n    import numpy as np\n    expected_properties = {\n        \"defect_instance_type\": {\n            \"format\": \"bool\",\n            \"value\": True\n        },\n        \"vacancy_count_for_specific_species\": {\n            \"format\": \"int\",\n            \"value\": 1\n        },\n        \"invalid_species_error\": {\n            \"format\": \"bool\",\n            \"value\": True\n        }\n    }\n    \n    errors = []\n    \n    for property_name, expected_info in expected_properties.items():\n        expected_value = expected_info['value']\n        expected_format = expected_info['format']\n        \n        if property_name not in properties:\n            errors.append(f\"{property_name} not found in input properties\")\n            continue\n        \n        actual_value = properties[property_name]\n        \n        # Check type (skip type check for np.allclose cases as it's handled separately)\n        if expected_format != \"np.allclose\" and not isinstance(actual_value, eval(expected_format)):\n            errors.append(f\"{property_name} is not of type {expected_format}\")\n            continue\n        \n        # Check value or use np.allclose for approximate comparisons\n        if expected_format == \"np.allclose\":\n            if not np.allclose(actual_value, expected_value):\n                errors.append(f\"{property_name}: Expected value close to {expected_value} but got {actual_value}\")\n        else:\n            if actual_value != expected_value:\n                errors.append(f\"{property_name}: Expected {expected_value} but got {actual_value}\")\n    \n    if errors:\n        print(\"failed:\", \"; \".join(errors))\n    else:\n        print(\"ok\")"
    },
    {
        "properties_json_str": "{\n  \"JSON_File_Name\": \"test_substitution_generators\",\n  \"properties\": {\n    \"defect_type\": {\n      \"description\": \"Checks if the generated defect is of type Substitution.\",\n      \"format\": \"bool\",\n      \"value\": \"True\"\n    },\n    \"replaced_atoms_set_1\": {\n      \"description\": \"Verifies the set of atoms that have been substituted in the structure, ensuring that Ga is replaced by either Mg or Ca.\",\n      \"format\": \"set\",\n      \"value\": \"{\\\"Mg\\\", \\\"Ca\\\"}\"\n    },\n    \"replaced_atoms_set_2\": {\n      \"description\": \"Verifies the set of atoms that have been substituted in the structure, ensuring that Ga is replaced by Mg.\",\n      \"format\": \"set\",\n      \"value\": \"{\\\"Mg\\\"}\"\n    }\n  }\n}",
        "question": "As a materials scientist, you are utilizing Pymatgen to write functions to calculate material properties. Here is what you need to do:\n- Calculate the following properties:\n    - `defect_type`: Checks if the generated defect is of type Substitution. The format is a boolean.\n    - `replaced_atoms_set_1`: Verifies the set of atoms that have been substituted in the structure, ensuring that Ga is replaced by either Mg or Ca. The format is a set.\n    - `replaced_atoms_set_2`: Verifies the set of atoms that have been substituted in the structure, ensuring that Ga is replaced by Mg. The format is a set.\n\nIf you need to read files or generate data, please refer to the following instructions:\n- Read or Generate Data:\n    - Access the structure file at: `<path>tool_source_code/pymatgen-analysis-defects/tests/test_files/GaN.vasp</path>`.\n    - Use the Pymatgen function:\n    ```python\n    from pymatgen.core import Structure\n    gan_struct = Structure.from_file(file_path / \"GaN.vasp\")\n    ```\n    - Generate substitution defects using Pymatgen's `SubstitutionGenerator`:\n    ```python\n    from pymatgen.analysis.defects.generators import SubstitutionGenerator\n    sub_generator_1 = SubstitutionGenerator().get_defects(gan_struct, {\"Ga\": [\"Mg\", \"Ca\"]})\n    sub_generator_2 = SubstitutionGenerator().get_defects(gan_struct, {\"Ga\": \"Mg\"})\n    ```\n\nAll content is executed within the function, and the function does not require any input to output the result. The format of the function should follow these guidelines:\n- Write a Python function that:\n    - Reads the data from the provided file paths or generates data based on the description in the first section.\n    - Calculates all the properties mentioned above using Pymatgen.\n    - Returns a dictionary where the property names are keys, and the calculated results are the values.\n\n- Ensure your function includes:\n    - Necessary imports (e.g., `from pymatgen.core import Structure`).\n    - Proper file handling or data generation code.\n    - Output in the form of a dictionary as specified above.\n    - A complete docstring with clear input parameters, data types, and a description of the output.\n\n**Write the required Python function for this task**.",
        "new_unit_test": "def test_substitution_generators(properties):\n    import numpy as np\n    expected_properties = {\n        \"defect_type\": {\n            \"format\": \"bool\",\n            \"value\": True\n        },\n        \"replaced_atoms_set_1\": {\n            \"format\": \"set\",\n            \"value\": {\"Mg\", \"Ca\"}\n        },\n        \"replaced_atoms_set_2\": {\n            \"format\": \"set\",\n            \"value\": {\"Mg\"}\n        }\n    }\n    \n    errors = []\n    \n    for property_name, expected_info in expected_properties.items():\n        expected_value = expected_info['value']\n        expected_format = expected_info['format']\n        \n        if property_name not in properties:\n            errors.append(f\"{property_name} not found in input properties\")\n            continue\n        \n        actual_value = properties[property_name]\n        \n        # Check type (skip type check for np.allclose cases as it's handled separately)\n        if expected_format != \"np.allclose\" and not isinstance(actual_value, eval(expected_format)):\n            errors.append(f\"{property_name} is not of type {expected_format}\")\n            continue\n        \n        # Check value or use np.allclose for approximate comparisons\n        if expected_format == \"np.allclose\":\n            if not np.allclose(actual_value, expected_value):\n                errors.append(f\"{property_name}: Expected value close to {expected_value} but got {actual_value}\")\n        else:\n            if actual_value != expected_value:\n                errors.append(f\"{property_name}: Expected {expected_value} but got {actual_value}\")\n    \n    if errors:\n        print(\"failed:\", \"; \".join(errors))\n    else:\n        print(\"ok\")"
    },
    {
        "properties_json_str": "{\n  \"JSON_File_Name\": \"test_antisite_generator\",\n  \"properties\": {\n    \"antisite_defect_names\": {\n      \"description\": \"Names of antisite defects generated from the given structure, indicating the swapping of atomic positions between different species.\",\n      \"format\": \"list\",\n      \"value\": [\"Ga_N\", \"N_Ga\"]\n    }\n  }\n}",
        "question": "As a materials scientist, you are utilizing Pymatgen to write functions to calculate material properties. Here is what you need to do:\n- Calculate the following properties:\n    - `antisite_defect_names`: Names of antisite defects generated from the given structure, indicating the swapping of atomic positions between different species. The format is a list of strings.\n\nIf you need to read files or generate data, please refer to the following instructions:\n- Read or Generate Data:\n    - Access the structure file at: `<path>tool_source_code/pymatgen-analysis-defects/tests/test_files/GaN.vasp</path>`.\n    - Use the Pymatgen function:\n    ```python\n    from pymatgen.core import Structure\n    gan_struct = Structure.from_file(file_path / \"GaN.vasp\")\n    ```\n    to read the structure data.\n    - Generate antisite defects using the Pymatgen function:\n    ```python\n    from pymatgen.analysis.defects.generators import AntiSiteGenerator\n    anti_gen = AntiSiteGenerator().get_defects(gan_struct)\n    def_names = [defect.name for defect in anti_gen]\n    ```\n\nAll content is executed within the function, and the function does not require any input to output the result. The format of the function should follow these guidelines:\n- Write a Python function that:\n    - Reads the data from the provided file paths or generates data based on the description in the first section.\n    - Calculates all the properties mentioned above using Pymatgen.\n    - Returns a dictionary where the property names are keys, and the calculated results are the values.\n\n- Ensure your function includes:\n    - Necessary imports (e.g., `from pymatgen.core import Structure`).\n    - Proper file handling or data generation code.\n    - Output in the form of a dictionary as specified above.\n    - A complete docstring with clear input parameters, data types, and a description of the output.\n\n**Write the required Python function for this task**.",
        "new_unit_test": "def test_antisite_generator(properties):\n    import numpy as np\n    expected_properties = {\n        \"antisite_defect_names\": {\n            \"format\": \"list\",\n            \"value\": [\"Ga_N\", \"N_Ga\"]\n        }\n    }\n    \n    errors = []\n    \n    for property_name, expected_info in expected_properties.items():\n        expected_value = expected_info['value']\n        expected_format = expected_info['format']\n        \n        if property_name not in properties:\n            errors.append(f\"{property_name} not found in input properties\")\n            continue\n        \n        actual_value = properties[property_name]\n        \n        # Check type (skip type check for np.allclose cases as it's handled separately)\n        if expected_format != \"np.allclose\" and not isinstance(actual_value, eval(expected_format)):\n            errors.append(f\"{property_name} is not of type {expected_format}\")\n            continue\n        \n        # Check value or use np.allclose for approximate comparisons\n        if expected_format == \"np.allclose\":\n            if not np.allclose(actual_value, expected_value):\n                errors.append(f\"{property_name}: Expected value close to {expected_value} but got {actual_value}\")\n        else:\n            if actual_value != expected_value:\n                errors.append(f\"{property_name}: Expected {expected_value} but got {actual_value}\")\n    \n    if errors:\n        print(\"failed:\", \"; \".join(errors))\n    else:\n        print(\"ok\")"
    },
    {
        "properties_json_str": "{\n  \"JSON_File_Name\": \"test_interstitial_generator\",\n  \"properties\": {\n    \"number_of_interstitials\": {\n      \"description\": \"The number of interstitial sites generated for a given structure and insertion sites.\",\n      \"format\": \"int\",\n      \"value\": 1\n    },\n    \"interstitial_site_description\": {\n      \"description\": \"String representation of the interstitial site, including the element and its coordinates.\",\n      \"format\": \"str\",\n      \"value\": \"Mg intersitial site at [0.00,0.00,0.00]\"\n    }\n  }\n}",
        "question": "As a materials scientist, you are utilizing Pymatgen to write functions to calculate material properties. Here is what you need to do:\n- Calculate the following properties:\n    - `number_of_interstitials`: The number of interstitial sites generated for a given structure and insertion sites. The format is an integer.\n    - `interstitial_site_description`: String representation of the interstitial site, including the element and its coordinates. The format is a string.\n\nIf you need to read files or generate data, please refer to the following instructions:\n- Read or Generate Data:\n    - Access the structure file at: `<path>tool_source_code/pymatgen-analysis-defects/tests/test_files/GaN.vasp</path>`.\n    - Use the Pymatgen function:\n    ```python\n    from pymatgen.core import Structure\n    gan_struct = Structure.from_file(file_path / \"GaN.vasp\")\n    ```\n    - Generate interstitial defects using the Pymatgen function:\n    ```python\n    from pymatgen.analysis.defects.generators import InterstitialGenerator\n    gen = InterstitialGenerator().get_defects(gan_struct, insertions={\"Mg\": [[0, 0, 0]]})\n    l_gen = list(gen)\n    ```\n\nAll content is executed within the function, and the function does not require any input to output the result. The format of the function should follow these guidelines:\n- Write a Python function that:\n    - Reads the data from the provided file paths or generates data based on the description in the first section.\n    - Calculates all the properties mentioned above using Pymatgen.\n    - Returns a dictionary where the property names are keys, and the calculated results are the values.\n\n- Ensure your function includes:\n    - Necessary imports (e.g., `from pymatgen.core import Structure`).\n    - Proper file handling or data generation code.\n    - Output in the form of a dictionary as specified above.\n    - A complete docstring with clear input parameters, data types, and a description of the output.\n\n**Write the required Python function for this task**.",
        "new_unit_test": "def test_test_interstitial_generator(properties):\n    import numpy as np\n    expected_properties = {\n        \"number_of_interstitials\": {\n            \"format\": \"int\",\n            \"value\": 1\n        },\n        \"interstitial_site_description\": {\n            \"format\": \"str\",\n            \"value\": \"Mg intersitial site at [0.00,0.00,0.00]\"\n        }\n    }\n    \n    errors = []\n    \n    for property_name, expected_info in expected_properties.items():\n        expected_value = expected_info['value']\n        expected_format = expected_info['format']\n        \n        if property_name not in properties:\n            errors.append(f\"{property_name} not found in input properties\")\n            continue\n        \n        actual_value = properties[property_name]\n        \n        # Check type (skip type check for np.allclose cases as it's handled separately)\n        if expected_format != \"np.allclose\" and not isinstance(actual_value, eval(expected_format)):\n            errors.append(f\"{property_name} is not of type {expected_format}\")\n            continue\n        \n        # Check value or use np.allclose for approximate comparisons\n        if expected_format == \"np.allclose\":\n            if not np.allclose(actual_value, expected_value):\n                errors.append(f\"{property_name}: Expected value close to {expected_value} but got {actual_value}\")\n        else:\n            if actual_value != expected_value:\n                errors.append(f\"{property_name}: Expected {expected_value} but got {actual_value}\")\n    \n    if errors:\n        print(\"failed:\", \"; \".join(errors))\n    else:\n        print(\"ok\")"
    },
    {
        "properties_json_str": "{\n  \"JSON_File_Name\": \"test_charge_interstitial_generator\",\n  \"properties\": {\n    \"defect_type\": {\n      \"description\": \"Checks if the generated defect is of type Interstitial.\",\n      \"format\": \"bool\",\n      \"value\": \"True\"\n    },\n    \"defect_specie\": {\n      \"description\": \"Verifies that the species of the interstitial site is Gallium (Ga).\",\n      \"format\": \"str\",\n      \"value\": \"Ga\"\n    },\n    \"defect_count\": {\n      \"description\": \"Ensures that the number of generated interstitial defects is exactly two.\",\n      \"format\": \"int\",\n      \"value\": \"2\"\n    }\n  }\n}",
        "question": "As a materials scientist, you are utilizing Pymatgen to write functions to calculate material properties. Here is what you need to do:\n- Calculate the following properties:\n    - `defect_type`: Checks if the generated defect is of type Interstitial. The format is a boolean.\n    - `defect_specie`: Verifies that the species of the interstitial site is Gallium (Ga). The format is a string.\n    - `defect_count`: Ensures that the number of generated interstitial defects is exactly two. The format is an integer.\n\nIf you need to read files or generate data, please refer to the following instructions:\n- Read or Generate Data:\n    - Access the CHGCAR file at: `<path>tool_source_code/pymatgen-analysis-defects/tests/test_files/CHGCAR.Fe3O4.vasp</path>`.\n    - Use the Pymatgen function ```python\\nfrom pymatgen.io.vasp.outputs import Chgcar\\nChgcar.from_file(file_path / \"CHGCAR.Fe3O4.vasp\")\\n``` to read the charge density data.\n    - Generate interstitial defects using the Pymatgen function: ```python\\nfrom pymatgen.analysis.defects.generators import ChargeInterstitialGenerator\\ngen = ChargeInterstitialGenerator().get_defects(chgcar_fe3o4, {\"Ga\"})\\n```.\n\nAll content is executed within the function, and the function does not require any input to output the result. The format of the function should follow these guidelines:\n- Write a Python function that:\n    - Reads the data from the provided file paths or generates data based on the description in the first section.\n    - Calculates all the properties mentioned above using Pymatgen.\n    - Returns a dictionary where the property names are keys, and the calculated results are the values.\n\n- Ensure your function includes:\n    - Necessary imports (e.g., `from pymatgen.io.vasp.outputs import Chgcar`).\n    - Proper file handling or data generation code.\n    - Output in the form of a dictionary as specified above.\n    - A complete docstring with clear input parameters, data types, and a description of the output.\n\n**Write the required Python function for this task**.",
        "new_unit_test": "def test_test_charge_interstitial_generator(properties):\n    import numpy as np\n    expected_properties = {\n        \"defect_type\": {\n            \"format\": \"bool\",\n            \"value\": True\n        },\n        \"defect_specie\": {\n            \"format\": \"str\",\n            \"value\": \"Ga\"\n        },\n        \"defect_count\": {\n            \"format\": \"int\",\n            \"value\": 2\n        }\n    }\n    \n    errors = []\n    \n    for property_name, expected_info in expected_properties.items():\n        expected_value = expected_info['value']\n        expected_format = expected_info['format']\n        \n        if property_name not in properties:\n            errors.append(f\"{property_name} not found in input properties\")\n            continue\n        \n        actual_value = properties[property_name]\n        \n        # Check type (skip type check for np.allclose cases as it's handled separately)\n        if expected_format != \"np.allclose\" and not isinstance(actual_value, eval(expected_format)):\n            errors.append(f\"{property_name} is not of type {expected_format}\")\n            continue\n        \n        # Check value or use np.allclose for approximate comparisons\n        if expected_format == \"np.allclose\":\n            if not np.allclose(actual_value, expected_value):\n                errors.append(f\"{property_name}: Expected value close to {expected_value} but got {actual_value}\")\n        else:\n            if actual_value != expected_value:\n                errors.append(f\"{property_name}: Expected {expected_value} but got {actual_value}\")\n    \n    if errors:\n        print(\"failed:\", \"; \".join(errors))\n    else:\n        print(\"ok\")"
    },
    {
        "properties_json_str": "{\n  \"JSON_File_Name\": \"test_voronoi_interstitial_generator\",\n  \"properties\": {\n    \"defect_type\": {\n      \"description\": \"Checks if the generated defect is of type Interstitial.\",\n      \"format\": \"bool\",\n      \"value\": \"True\"\n    },\n    \"defect_specie\": {\n      \"description\": \"Verifies that the interstitial defect is of the specified element, in this case, Lithium (Li).\",\n      \"format\": \"str\",\n      \"value\": \"Li\"\n    },\n    \"defect_count\": {\n      \"description\": \"Ensures the correct number of interstitial defects are generated.\",\n      \"format\": \"int\",\n      \"value\": \"4\"\n    }\n  }\n}",
        "question": "As a materials scientist, you are utilizing Pymatgen to write functions to calculate material properties. Here is what you need to do:\n- Calculate the following properties:\n    - `defect_type`: Checks if the generated defect is of type Interstitial. The format is a boolean.\n    - `defect_specie`: Verifies that the interstitial defect is of the specified element, in this case, Lithium (Li). The format is a string.\n    - `defect_count`: Ensures the correct number of interstitial defects are generated. The format is an integer.\n\nIf you need to read files or generate data, please refer to the following instructions:\n- Read or Generate Data:\n    - Access the CHGCAR file at: `<path>tool_source_code/pymatgen-analysis-defects/tests/test_files/CHGCAR.Fe3O4.vasp</path>`.\n    - Use the Pymatgen function ```python\\nfrom pymatgen.io.vasp.outputs import Chgcar\\nChgcar.from_file(file_path / \"CHGCAR.Fe3O4.vasp\")\\n``` to read the charge density data.\n    - Generate interstitial defects using the VoronoiInterstitialGenerator with the structure obtained from the CHGCAR file and the element set {\"Li\"}.\n\nAll content is executed within the function, and the function does not require any input to output the result. The format of the function should follow these guidelines:\n- Write a Python function that:\n    - Reads the data from the provided file paths or generates data based on the description in the first section.\n    - Calculates all the properties mentioned above using Pymatgen.\n    - Returns a dictionary where the property names are keys, and the calculated results are the values.\n\n- Ensure your function includes:\n    - Necessary imports (e.g., `from pymatgen.io.vasp.outputs import Chgcar`).\n    - Proper file handling or data generation code.\n    - Output in the form of a dictionary as specified above.\n    - A complete docstring with clear input parameters, data types, and a description of the output.\n\n**Write the required Python function for this task**.",
        "new_unit_test": "def test_voronoi_interstitial_generator(properties):\n    import numpy as np\n    expected_properties = {\n        \"defect_type\": {\n            \"format\": \"bool\",\n            \"value\": True\n        },\n        \"defect_specie\": {\n            \"format\": \"str\",\n            \"value\": \"Li\"\n        },\n        \"defect_count\": {\n            \"format\": \"int\",\n            \"value\": 4\n        }\n    }\n    \n    errors = []\n    \n    for property_name, expected_info in expected_properties.items():\n        expected_value = expected_info['value']\n        expected_format = expected_info['format']\n        \n        if property_name not in properties:\n            errors.append(f\"{property_name} not found in input properties\")\n            continue\n        \n        actual_value = properties[property_name]\n        \n        # Check type\n        if not isinstance(actual_value, eval(expected_format)):\n            errors.append(f\"{property_name} is not of type {expected_format}\")\n            continue\n        \n        # Check value\n        if actual_value != expected_value:\n            errors.append(f\"{property_name}: Expected {expected_value} but got {actual_value}\")\n    \n    if errors:\n        print(\"failed:\", \"; \".join(errors))\n    else:\n        print(\"ok\")"
    },
    {
        "properties_json_str": "{\n  \"JSON_File_Name\": \"test_generate_all_native_defects\",\n  \"properties\": {\n    \"number_of_defects_with_chgcar\": {\n      \"description\": \"The total number of native defects generated when using a CHGCAR file as input.\",\n      \"format\": \"int\",\n      \"value\": 14\n    },\n    \"number_of_defects_with_structure\": {\n      \"description\": \"The total number of native defects generated when using a structure object as input.\",\n      \"format\": \"int\",\n      \"value\": 10\n    }\n  }\n}",
        "question": "As a materials scientist, you are utilizing Pymatgen to write functions to calculate material properties. Here is what you need to do:\n- Calculate the following properties:\n    - `number_of_defects_with_chgcar`: The total number of native defects generated when using a CHGCAR file as input. The format is an integer.\n    - `number_of_defects_with_structure`: The total number of native defects generated when using a structure object as input. The format is an integer.\n\nIf you need to read files or generate data, please refer to the following instructions:\n- Read or Generate Data:\n    - Access the CHGCAR file at: `<path>tool_source_code/pymatgen-analysis-defects/tests/test_files/CHGCAR.Fe3O4.vasp</path>`.\n    - Use the Pymatgen function ```python\\nfrom pymatgen.io.vasp.outputs import Chgcar\\nChgcar.from_file(file_path / \"CHGCAR.Fe3O4.vasp\")\\n``` to read the CHGCAR data.\n    - Access the structure file at: `<path>tool_source_code/pymatgen-analysis-defects/tests/test_files/CHGCAR.Fe3O4.vasp</path>`.\n    - Use the Pymatgen function ```python\\nfrom pymatgen.core import Structure\\nStructure.from_file(file_path / \"CHGCAR.Fe3O4.vasp\")\\n``` to read the structure data.\n\nAll content is executed within the function, and the function does not require any input to output the result. The format of the function should follow these guidelines:\n- Write a Python function that:\n    - Reads the data from the provided file paths or generate data based on the description in the first section.\n    - Calculates all the properties mentioned above using Pymatgen.\n    - Returns a dictionary where the property names are keys, and the calculated results are the values.\n\n- Ensure your function includes:\n    - Necessary imports (e.g., `from pymatgen.io.vasp.outputs import Chgcar`).\n    - Proper file handling or data generation code.\n    - Output in the form of a dictionary as specified above.\n    - A complete docstring with clear input parameters, data types, and a description of the output.\n\n**Write the required Python function for this task**.",
        "new_unit_test": "def test_generate_all_native_defects(properties):\n    import numpy as np\n    expected_properties = {\n        \"number_of_defects_with_chgcar\": {\n            \"format\": \"int\",\n            \"value\": 14\n        },\n        \"number_of_defects_with_structure\": {\n            \"format\": \"int\",\n            \"value\": 10\n        }\n    }\n    \n    errors = []\n    \n    for property_name, expected_info in expected_properties.items():\n        expected_value = expected_info['value']\n        expected_format = expected_info['format']\n        \n        if property_name not in properties:\n            errors.append(f\"{property_name} not found in input properties\")\n            continue\n        \n        actual_value = properties[property_name]\n        \n        # Check type (skip type check for np.allclose cases as it's handled separately)\n        if expected_format != \"np.allclose\" and not isinstance(actual_value, eval(expected_format)):\n            errors.append(f\"{property_name} is not of type {expected_format}\")\n            continue\n        \n        # Check value or use np.allclose for approximate comparisons\n        if expected_format == \"np.allclose\":\n            if not np.allclose(actual_value, expected_value):\n                errors.append(f\"{property_name}: Expected value close to {expected_value} but got {actual_value}\")\n        else:\n            if actual_value != expected_value:\n                errors.append(f\"{property_name}: Expected {expected_value} but got {actual_value}\")\n    \n    if errors:\n        print(\"failed:\", \"; \".join(errors))\n    else:\n        print(\"ok\")"
    },
    {
        "properties_json_str": "{\n  \"JSON_File_Name\": \"test_fed_plot\",\n  \"properties\": {\n    \"formation_energy_diagram_names\": {\n      \"description\": \"Checks if the names of the data series in the formation energy diagram match the expected defect names.\",\n      \"format\": \"set\",\n      \"value\": \"{\\\"Mg_Ga\\\", \\\"Mg_Ga:slope\\\"}\"\n    }\n  }\n}",
        "question": "As a materials scientist, you are utilizing Pymatgen to write functions to calculate material properties. Here is what you need to do:\n- Calculate the following properties:\n    - `formation_energy_diagram_names`: Checks if the names of the data series in the formation energy diagram match the expected defect names. The format is a set.\n\nIf you need to read files or generate data, please refer to the following instructions:\n- Read or Generate Data:\n    - Access the structure file at: `<path>tool_source_code/pymatgen-analysis-defects/tests/test_files/GaN.vasp</path>`.\n    - Use the Pymatgen function ```python\\nfrom pymatgen.core import Structure\\nStructure.from_file(file_path / \"GaN.vasp\")\\n``` to read the structure data.\n    - Access the JSON file at: `<path>tool_source_code/pymatgen-analysis-defects/tests/test_files/stable_entries_Mg_Ga_N.json</path>`.\n    - Use the Pymatgen function ```python\\nfrom monty.serialization import loadfn\\nloadfn(file_path / \"stable_entries_Mg_Ga_N.json\")\\n``` to read the stable entries data.\n    - Generate defect data using the following Pymatgen functions:\n      ```python\n      from pymatgen.analysis.defects.core import PeriodicSite, Substitution\n      from pymatgen.core.periodic_table import Specie\n      ga_site = gan_struct[0]\n      mg_site = PeriodicSite(Specie(\"Mg\"), ga_site.frac_coords, gan_struct.lattice)\n      defect_Mg_Ga = Substitution(gan_struct, mg_site)\n      ```\n    - Access the directory for defect data at: `<path>tool_source_code/pymatgen-analysis-defects/tests/test_files/Mg_Ga</path>`.\n    - Use the Pymatgen function ```python\\nfrom pymatgen.io.vasp.outputs import Vasprun, Locpot\\nVasprun(fold / \"vasprun.xml.gz\")\\nLocpot.from_file(fold / \"LOCPOT.gz\")\\n``` to read the defect data.\n    - Generate defect entries and plot data using the following Pymatgen functions:\n      ```python\n      from pymatgen.analysis.defects.thermo import DefectEntry\n      bulk_locpot = data_Mg_Ga[\"bulk_sc\"][\"locpot\"]\n      computed_entry = data_Mg_Ga[f\"q={q}\"][\"vasprun\"].get_computed_entry(inc_structure=True)\n      defect_locpot = data_Mg_Ga[f\"q={q}\"][\"locpot\"]\n      def_entry = DefectEntry(defect=defect_Mg_Ga, charge_state=q, sc_entry=computed_entry)\n      frey_summary = def_entry.get_freysoldt_correction(defect_locpot=defect_locpot, bulk_locpot=bulk_locpot, dielectric=14)\n      ```\n    - Generate the formation energy diagram using the following Pymatgen functions:\n      ```python\n      from pymatgen.analysis.phase_diagram import PhaseDiagram\n      from pymatgen.analysis.defects.thermo import FormationEnergyDiagram\n      pd = PhaseDiagram(stable_entries_Mg_Ga_N)\n      fed = FormationEnergyDiagram.with_atomic_entries(\n          defect_entries=def_ent_list,\n          atomic_entries=atomic_entries,\n          vbm=vbm,\n          inc_inf_values=False,\n          phase_diagram=pd,\n          bulk_entry=bulk_entry,\n      )\n      ```\n\nAll content is executed within the function, and the function does not require any input to output the result. The format of the function should follow these guidelines:\n- Write a Python function that:\n    - Reads the data from the provided file paths or generate data based on the description in the first section.\n    - Calculates all the properties mentioned above using Pymatgen.\n    - Returns a dictionary where the property names are keys, and the calculated results are the values.\n\n- Ensure your function includes:\n    - Necessary imports (e.g., `from pymatgen.core import Structure`).\n    - Proper file handling or data generation code.\n    - Output in the form of a dictionary as specified above.\n    - A complete docstring with clear input parameters, data types, and a description of the output.\n\n**Write the required Python function for this task**.",
        "new_unit_test": "def test_fed_plot(properties):\n    import numpy as np\n    expected_properties = {\n        \"formation_energy_diagram_names\": {\n            \"format\": \"set\",\n            \"value\": {\"Mg_Ga\", \"Mg_Ga:slope\"}\n        }\n    }\n    \n    errors = []\n    \n    for property_name, expected_info in expected_properties.items():\n        expected_value = expected_info['value']\n        expected_format = expected_info['format']\n        \n        if property_name not in properties:\n            errors.append(f\"{property_name} not found in input properties\")\n            continue\n        \n        actual_value = properties[property_name]\n        \n        # Check type (skip type check for np.allclose cases as it's handled separately)\n        if expected_format != \"np.allclose\" and not isinstance(actual_value, eval(expected_format)):\n            errors.append(f\"{property_name} is not of type {expected_format}\")\n            continue\n        \n        # Check value or use np.allclose for approximate comparisons\n        if expected_format == \"np.allclose\":\n            if not np.allclose(actual_value, expected_value):\n                errors.append(f\"{property_name}: Expected value close to {expected_value} but got {actual_value}\")\n        else:\n            if actual_value != expected_value:\n                errors.append(f\"{property_name}: Expected {expected_value} but got {actual_value}\")\n    \n    if errors:\n        print(\"failed:\", \"; \".join(errors))\n    else:\n        print(\"ok\")"
    },
    {
        "properties_json_str": "{\n  \"JSON_File_Name\": \"test_chempot_plot\",\n  \"properties\": {\n    \"chemical_potential_plot\": {\n      \"description\": \"This property tests the ability to generate a 2D plot of chemical potentials for a given set of elements, which is crucial for understanding the stability of phases in a multicomponent system.\",\n      \"format\": \"Function call with parameters\",\n      \"value\": \"plot_chempot_2d(basic_fed, x_element=Element('Mg'), y_element=Element('Ga'))\"\n    }\n  }\n}",
        "question": "As a materials scientist, you are utilizing Pymatgen to write functions to calculate material properties. Here is what you need to do:\n- Calculate the following properties:\n    - `chemical_potential_plot`: This property tests the ability to generate a 2D plot of chemical potentials for a given set of elements, which is crucial for understanding the stability of phases in a multicomponent system. The format is a function call with parameters.\n\nIf you need to read files or generate data, please refer to the following instructions:\n- Read or Generate Data:\n    - Access the structure file at: `<path>tool_source_code/pymatgen-analysis-defects/tests/test_files/GaN.vasp</path>`.\n    - Use the Pymatgen function ```python\\nfrom pymatgen.core import Structure\\nStructure.from_file(file_path / \"GaN.vasp\")\\n``` to read the structure data.\n    - Access the JSON file containing stable entries at: `<path>tool_source_code/pymatgen-analysis-defects/tests/test_files/stable_entries_Mg_Ga_N.json</path>`.\n    - Use the Monty function ```python\\nfrom monty.serialization import loadfn\\nloadfn(file_path / \"stable_entries_Mg_Ga_N.json\")\\n``` to read the stable entries data.\n    - Generate the FormationEnergyDiagram using the Pymatgen function: ```python\\nfrom pymatgen.analysis.defects.thermo import FormationEnergyDiagram\\nfrom pymatgen.analysis.phase_diagram import PhaseDiagram\\nfrom pymatgen.core import Element\\n# Assume defect_entries and atomic_entries are already defined\\npd = PhaseDiagram(stable_entries)\\nfed = FormationEnergyDiagram.with_atomic_entries(defect_entries=def_ent_list, atomic_entries=atomic_entries, vbm=vbm, inc_inf_values=False, phase_diagram=pd, bulk_entry=bulk_entry)\\n```.\n    - Use the Pymatgen function ```python\\nfrom pymatgen.analysis.defects.plotting.thermo import plot_chempot_2d\\nplot_chempot_2d(fed, x_element=Element(\"Mg\"), y_element=Element(\"Ga\"))\\n``` to generate the chemical potential plot.\n\nAll content is executed within the function, and the function does not require any input to output the result. The format of the function should follow these guidelines:\n- Write a Python function that:\n    - Reads the data from the provided file paths or generate data based on the description in the first section.\n    - Calculates all the properties mentioned above using Pymatgen.\n    - Returns a dictionary where the property names are keys, and the calculated results are the values.\n\n- Ensure your function includes:\n    - Necessary imports (e.g., `from pymatgen.core import Structure`).\n    - Proper file handling or data generation code.\n    - Output in the form of a dictionary as specified above.\n    - A complete docstring with clear input parameters, data types, and a description of the output.\n\n**Write the required Python function for this task**.",
        "new_unit_test": "def test_chempot_plot(properties):\n    import numpy as np\n    from pymatgen.core import Element\n    \n    expected_properties = {\n        \"chemical_potential_plot\": {\n            \"format\": \"Function call with parameters\",\n            \"value\": \"plot_chempot_2d(basic_fed, x_element=Element('Mg'), y_element=Element('Ga'))\"\n        }\n    }\n    \n    errors = []\n    \n    for property_name, expected_info in expected_properties.items():\n        expected_value = expected_info['value']\n        expected_format = expected_info['format']\n        \n        if property_name not in properties:\n            errors.append(f\"{property_name} not found in input properties\")\n            continue\n        \n        actual_value = properties[property_name]\n        \n        # Check if the actual function call matches the expected function call\n        if expected_format == \"Function call with parameters\":\n            if actual_value != expected_value:\n                errors.append(f\"{property_name}: Expected function call {expected_value} but got {actual_value}\")\n        else:\n            errors.append(f\"{property_name}: Unsupported format {expected_format}\")\n    \n    if errors:\n        print(\"failed:\", \"; \".join(errors))\n    else:\n        print(\"ok\")"
    }
]