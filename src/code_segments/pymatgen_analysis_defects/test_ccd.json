{
    "uuid": "dfb77d85-3474-464e-a88b-334e5ef099f8",
    "filename": "/Users/siyuliu/Desktop/MacBot/src/tool_source_code/pymatgen-analysis-defects/tests/test_ccd.py",
    "imports": [
        "from collections import namedtuple",
        "import numpy as np",
        "import pandas as pd",
        "import pytest",
        "from pymatgen.analysis.defects.ccd import (\n    HarmonicDefect,\n    _get_wswq_slope,\n    plot_pes,\n)",
        "from pymatgen.analysis.defects.plotting.optics import plot_optical_transitions",
        "from pymatgen.io.vasp.outputs import Waveder"
    ],
    "classes": [],
    "global functions": [
        "def test_defect_band_raises(v_ga) -> None:\n    vaspruns = v_ga[(0, -1)][\"vaspruns\"]\n    procar = v_ga[(0, -1)][\"procar\"]\n    hd0 = HarmonicDefect.from_vaspruns(\n        vaspruns,\n        charge_state=0,\n        procar=procar,\n        store_bandstructure=True,\n    )\n    # mis-matched defect band\n    hd0.defect_band = [(138, 0, 1), (139, 1, 1)]\n    with pytest.raises(ValueError):\n        assert hd0.defect_band_index\n\n    # mis-matched defect spin\n    hd0.defect_band = [(138, 0, 1), (138, 1, 0)]\n    with pytest.raises(ValueError):\n        assert hd0.spin_index == 1",
        "def test_HarmonicDefect(hd0, v_ga, test_dir) -> None:\n    # test other basic reading functions for HarmonicDefect\n    vaspruns = v_ga[(0, -1)][\"vaspruns\"]\n    procar = v_ga[(0, -1)][\"procar\"]\n    hd0 = HarmonicDefect.from_vaspruns(\n        vaspruns,\n        charge_state=0,\n        procar=procar,\n        store_bandstructure=True,\n    )\n    assert hd0.defect_band == [(138, 0, 1), (138, 1, 1)]\n\n    hd0p = HarmonicDefect.from_directories(\n        directories=[test_dir / \"v_Ga\" / \"ccd_0_-1\" / str(i) for i in range(3)],\n        charge_state=0,\n    )\n    assert hd0p.defect_band == [(138, 0, 1), (138, 1, 1)]\n\n    hd2 = HarmonicDefect.from_vaspruns(\n        vaspruns, charge_state=0, procar=procar, defect_band=((139, 0, 1), (139, 1, 1))\n    )\n    assert hd2.spin_index == 1\n\n    vaspruns = v_ga[(0, -1)][\"vaspruns\"]\n    procar = v_ga[(0, -1)][\"procar\"]\n    # check for ValueError when you have non-unique spin for the defect band\n    with pytest.raises(ValueError) as e:\n        hd3 = HarmonicDefect.from_vaspruns(\n            vaspruns,\n            charge_state=0,\n            procar=procar,\n            defect_band=((139, 0, 1), (139, 1, 0)),\n        )\n        hd3.spin\n    assert \"Spin index\" in str(e.value)",
        "def test_wswq(hd0, test_dir) -> None:\n    wswq_dir = test_dir / \"v_Ga\" / \"ccd_0_-1\" / \"wswqs\"\n\n    # check for ValueError when you have mis-matched distortions and wswqs\n    with pytest.raises(ValueError) as e:\n        hd0.read_wswqs(\n            directory=wswq_dir,\n            distortions=[\n                1,\n            ],\n        )\n    assert \"distortions\" in str(e.value)\n\n    hd0.read_wswqs(wswq_dir)\n    elph_me = hd0.get_elph_me((138, 1, 1))\n    assert np.allclose(elph_me[..., 138], 0.0)  # ediff should be zero for defect band\n    assert np.linalg.norm(elph_me[..., 139]) > 0",
        "def test_wswq_slope() -> None:\n    # Make sure the the slope is automatically defined as the sign of the distoration changes.\n    mats = [np.ones((3, 5)), np.zeros((3, 5)), np.ones((3, 5))]\n    FakeWSWQ = namedtuple(\"FakeWSWQ\", [\"data\"])\n    fake_wswqs = [FakeWSWQ(data=m) for m in mats]\n\n    res = _get_wswq_slope([-0.5, 0, 0.5], fake_wswqs)\n    assert np.allclose(res, np.ones((3, 5)) * 2)\n\n    res = _get_wswq_slope([1.0, 0, -1.0], fake_wswqs)\n    assert np.allclose(res, np.ones((3, 5)) * 1)",
        "def test_SRHCapture(hd0, hd1, test_dir) -> None:\n    from pymatgen.analysis.defects.ccd import get_SRH_coefficient\n\n    hd0.read_wswqs(test_dir / \"v_Ga\" / \"ccd_0_-1\" / \"wswqs\")\n    c_n = get_SRH_coefficient(\n        initial_state=hd0,\n        final_state=hd1,\n        defect_state=(138, 1, 1),\n        T=[100, 200, 300],\n        dE=1.0,\n    )\n    ref_results = [1.89187260e-34, 6.21019152e-33, 3.51501688e-31]\n    assert np.allclose(c_n, ref_results)\n\n    # expect RuntimeError\n    with pytest.raises(RuntimeError) as e:\n        get_SRH_coefficient(\n            initial_state=hd0,\n            final_state=hd1,\n            defect_state=hd1.defect_band[-1],\n            T=[100, 200, 300],\n            dE=1.0,\n            use_final_state_elph=True,\n        )\n    assert \"WSWQ\" in str(e.value)",
        "def test_dielectric_func(test_dir) -> None:\n    dir0_opt = test_dir / \"v_Ga\" / \"ccd_0_-1\" / \"optics\"\n    hd0 = HarmonicDefect.from_directories(\n        directories=[dir0_opt],\n        store_bandstructure=True,\n    )\n    hd0.waveder = Waveder.from_binary(dir0_opt / \"WAVEDER\")\n    energy, eps_vbm, eps_cbm = hd0.get_dielectric_function(idir=0, jdir=0)\n    inter_vbm = np.trapz(np.imag(eps_vbm[:100]), energy[:100])\n    inter_cbm = np.trapz(np.imag(eps_cbm[:100]), energy[:100])\n    assert pytest.approx(inter_vbm, abs=0.01) == 6.31\n    assert pytest.approx(inter_cbm, abs=0.01) == 0.27\n\n    df, cmap, norm = plot_optical_transitions(hd0, kpt_index=0, band_window=5)\n    assert isinstance(df, pd.DataFrame)\n    assert len(df) == 11\n\n    df, cmap, norm = plot_optical_transitions(\n        hd0,\n        kpt_index=-100,\n        band_window=5,\n        user_defect_band=(100, 0, 0),\n        shift_eig={100: 0},\n    )\n    assert df.iloc[5][\"ib\"] == 100\n    assert df.iloc[5][\"jb\"] == 100",
        "def test_plot_pes(hd0) -> None:\n    plot_pes(hd0)"
    ],
    "global variables": []
}